{
  "post_stream": {
    "posts": [
      {
        "id": 5801,
        "name": "Christophe Chevalier",
        "username": "KrzysFR",
        "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
        "created_at": "2019-12-11T22:52:33.891Z",
        "cooked": "<p>In a transaction, if I update the <code>\\xff/metadataVersion</code> key, and then attempt to read it again, I get a \u201cRead or wrote an unreadable key\u201d error (1036) when trying to read again. That was a bit surprising at first, but it seems it is the side effecting of using versionstamps that are not known under after commit, and <a href=\"https://github.com/apple/foundationdb/issues/2436\" rel=\"nofollow noopener\">is the expected behavior</a>.</p>\n<p>Looking at <a href=\"https://github.com/FoundationDB/fdb-record-layer/blob/2953315650f0c426a32bc4486f7e0596185a9d40/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBRecordContext.java#L879\" rel=\"nofollow noopener\">the implementation in the record layer</a>, it seems to specifically catch this error, and return the <code>null</code> versionstamp instead. I changed my code to do the same thing if the read fails.</p>\n<p>My surprise is that then if I attempt to <em>commit</em> the transaction, then the commit also fails with the same error \u2026 ? Using snapshot isolation or not has no impact. The error is throw by <code>fdb_transaction_commit</code>, and is rethrown by <code>fdb_transaction_on_error</code>.</p>\n<pre><code class=\"lang-nohighlight\">Transaction #5 (read/write, 4 operations, '#' = 0.5 ms, started 22:24:26.1274739Z, ended 22:24:26.1584759Z)\n\u250c  oper. \u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500 start \u2500\u2500\u2500\u2500 end \u2500\u2500 duration \u2500\u2500\u252c\u2500 sent  recv \u2510\n\u2502 0   a  \u2502 X                                                               \u2502 T+  1.841 ~   2.196 (    355 \u00b5s) \u2502    31       \u2502 Atomic_VersionStampedValue &lt;FF&gt;/metadataVersion, &lt;00 00 00 00 00 00 00 00 00 00&gt;\n\u2502 1   mv\u00b0\u2502 :###`                                                           \u2502 T+  2.199 ~   3.746 (  1,547 \u00b5s) \u2502             \u2502 GetMetadataVersion =&gt; [AccessedUnreadable] =&gt; &lt;null&gt;\n\u2502 2  !Co*\u2502 _______$###################################################X    \u2502 T+  5.270 ~  30.141 ( 24,871 \u00b5s) \u2502             \u2502 Commit =&gt; [AccessedUnreadable] Read or wrote an unreadable key\n\u2502 3  !Er\u00b0\u2502 ____________________________________________________________=## \u2502 T+ 30.516 ~  31.707 (  1,192 \u00b5s) \u2502             \u2502 OnError AccessedUnreadable (1036) =&gt; [AccessedUnreadable] Read or wrote an unreadable key\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n<p><em>note: timings are weird because it\u2019s a unit test and the JIT has to compile all the code on the fly!</em></p>\n<p>What is then the point of catching the error when reading the key, if it will inevitably throw the same error at commit time? This means that any combinations of layers, one that mutate the schema, and another that attempts to use a cache, will systematically throw at commit time.</p>\n<p>The record-layer attempts to keep a <code>dirtyMetaDataVersionStamp</code> flag that knows that it has already been changed and not even attempt to read the key (and doom the transaction) but:</p>\n<ol>\n<li>it only works locally for the record-layer, not if another layer changes the key separately.</li>\n<li>it seems racy (no locks) if multiple threads use the same transaction.</li>\n<li>if the read still happens somehow, and the error is caught, the code sets the flag to true but it will still fail to commit later, so \u2026 ??</li>\n</ol>\n<p>Either I missing something critical, or it means that it is impossible to compose two layers that use the metadataVersion key for caching in the same read/write transaction?</p>\n<p>I could maybe see moving this \u201cdirty versionstamp\u201d protection logic from layer code up to the binding itself, so that no one can slip past, but then I\u2019m not sure if this would be race-proof: both a read and write happening on the metadataVersion key for same transaction.</p>",
        "post_number": 1,
        "post_type": 1,
        "posts_count": 7,
        "updated_at": "2019-12-11T22:52:53.568Z",
        "reply_count": 1,
        "reply_to_post_number": null,
        "quote_count": 0,
        "incoming_link_count": 145,
        "reads": 45,
        "readers_count": 44,
        "score": 734.0,
        "yours": false,
        "topic_id": 1833,
        "topic_slug": "cannot-commit-transaction-that-reads-the-metadataversion-key-after-changing-it",
        "display_username": "Christophe Chevalier",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "link_counts": [
          {
            "url": "https://github.com/apple/foundationdb/issues/2436",
            "internal": false,
            "reflection": false,
            "title": "Attempt to read metadataVersion key in snapshot isolation fails with `Read or wrote an unreadable key` after changing it \u00b7 Issue #2436 \u00b7 apple/foundationdb \u00b7 GitHub",
            "clicks": 8
          },
          {
            "url": "https://github.com/FoundationDB/fdb-record-layer/blob/2953315650f0c426a32bc4486f7e0596185a9d40/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBRecordContext.java#L879",
            "internal": false,
            "reflection": false,
            "title": "fdb-record-layer/FDBRecordContext.java at 2953315650f0c426a32bc4486f7e0596185a9d40 \u00b7 FoundationDB/fdb-record-layer \u00b7 GitHub",
            "clicks": 1
          },
          {
            "url": "https://forums.foundationdb.org/t/how-to-safely-add-a-metadata-caching-layer-on-top-of-existing-layers/1809/2",
            "internal": true,
            "reflection": true,
            "title": "How to safely add a metadata caching \"layer\" on top of existing layers?",
            "clicks": 1
          }
        ],
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 53,
        "hidden": false,
        "trust_level": 2,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/cannot-commit-transaction-that-reads-the-metadataversion-key-after-changing-it/1833/1",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null,
        "can_vote": false
      },
      {
        "id": 5809,
        "name": "Alec Grieser",
        "username": "alloc",
        "avatar_template": "/user_avatar/forums.foundationdb.org/alloc/{size}/9_2.png",
        "created_at": "2019-12-12T15:43:57.839Z",
        "cooked": "<aside class=\"quote no-group\" data-username=\"KrzysFR\" data-post=\"1\" data-topic=\"1833\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/krzysfr/48/43_2.png\" class=\"avatar\"> KrzysFR:</div>\n<blockquote>\n<p>My surprise is that then if I attempt to <em>commit</em> the transaction, then the commit also fails with the same error \u2026 ?</p>\n</blockquote>\n</aside>\n<p>I believe the idea is that if your transaction ever reads one of these keys, then it is assumed that there is some logic error, so one can\u2019t rely on the value one computed. I\u2019m\u2026not sure that\u2019s necessarily correct all of the time, and it\u2019s also perhaps I\u2019m missing something in the rationale. Perhaps <a class=\"mention\" href=\"/u/evan\">@Evan</a> has more on that?</p>\n<aside class=\"quote no-group\" data-username=\"KrzysFR\" data-post=\"1\" data-topic=\"1833\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/krzysfr/48/43_2.png\" class=\"avatar\"> KrzysFR:</div>\n<blockquote>\n<p>if the read still happens somehow, and the error is caught, the code sets the flag to true but it will still fail to commit later, so \u2026 ??</p>\n</blockquote>\n</aside>\n<p>Right. But the benefit is that if, somehow, the transaction is not committed because, for example, the user decides what they really wanted was for it to be a read-only operation, then at least their reads succeed. It\u2019s not a huge benefit, but it\u2019s there. (And it sets <code>dirtyMetaDataVersionStamp</code> to <code>true</code> so that at least if future callers call the function, then they don\u2019t need to make a JNI hop to determine that they will just get an error anyway.)</p>\n<p>I\u2019ll also say that when I wrote it, I, too, thought that the error would be isolated to the read, and then by catching the error, I would still be able to commit the transaction. When that ended up being not the case, it seemed worthwhile to keep it in (because of what I mentioned in the above paragraph), though it\u2019s definitely not as useful as one that allowed a full read-write transaction to take place.</p>\n<aside class=\"quote no-group\" data-username=\"KrzysFR\" data-post=\"1\" data-topic=\"1833\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/krzysfr/48/43_2.png\" class=\"avatar\"> KrzysFR:</div>\n<blockquote>\n<p>it seems racy (no locks) if multiple threads use the same transaction.</p>\n</blockquote>\n</aside>\n<p>Yeah, a little bit. I believe the actual race is:</p>\n<ol>\n<li>A user calls <code>getMetaDataVersionStamp</code>, which checks if the version stamp is dirty. Let\u2019s say that the value is currently <code>false</code>, so it moves on, but is halted before it begins to actually read.</li>\n<li>A different thread then calls <code>setMetaDataVersionStamp</code>, which mutates the key.</li>\n<li>The original thread resumes. It then reads the (mutated) key and hits the error.</li>\n</ol>\n<p>I think one could actually patch the race by: (1) setting <code>dirtyMetaDataVersionStamp</code> to <code>true</code> and actually setting the key in one synchronized block (or critical section or what have you) and (2) checking the value of the key and then spawning the future to read the key in another synchronized block (but not waiting on the future necessarily). I think that would work, but it depends on the FDB operation being placed onto the network thread before returning, which I think is true of the client. (So then if a write to the meta-data version key comes in while a read is outstanding, it will be applied after the read completes. Or I think those are the semantics without having actually tested them.)</p>\n<p>I was aware of the race when I wrote this code, but I suppose I hadn\u2019t quite thought through how one could make it work by relying on serializing steps onto the FDB network thread. I\u2019ll also note that this race only means that some things that should have succeeded (by correctly ordering their accesses to this key) might fail with error 1036. That\u2019s not fantastic, but it doesn\u2019t corrupt the meta-data.</p>\n<aside class=\"quote no-group\" data-username=\"KrzysFR\" data-post=\"1\" data-topic=\"1833\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/krzysfr/48/43_2.png\" class=\"avatar\"> KrzysFR:</div>\n<blockquote>\n<p>Either I missing something critical, or it means that it is impossible to compose two layers that use the metadataVersion key for caching in the same read/write transaction?</p>\n<p>I could maybe see moving this \u201cdirty versionstamp\u201d protection logic from layer code up to the binding itself, so that no one can slip past, but then I\u2019m not sure if this would be race-proof: both a read and write happening on the metadataVersion key for same transaction.</p>\n</blockquote>\n</aside>\n<p>Yeah, I suspect it\u2019s impossible (for certain definitions of compose) without either bubbling down this dirty versionstamp protection to either the bindings or to some kind of common library that is shared by all layers. It would be great if this were race proof (possibly realized by the logic I outlined above with a few extra critical sections); if not, the protection even in its racy form can go a long way.</p>",
        "post_number": 2,
        "post_type": 1,
        "posts_count": 7,
        "updated_at": "2019-12-12T15:43:57.839Z",
        "reply_count": 2,
        "reply_to_post_number": null,
        "quote_count": 1,
        "incoming_link_count": 2,
        "reads": 37,
        "readers_count": 36,
        "score": 27.4,
        "yours": false,
        "topic_id": 1833,
        "topic_slug": "cannot-commit-transaction-that-reads-the-metadataversion-key-after-changing-it",
        "display_username": "Alec Grieser",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 8,
        "hidden": false,
        "trust_level": 4,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/cannot-commit-transaction-that-reads-the-metadataversion-key-after-changing-it/1833/2",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 5811,
        "name": "Christophe Chevalier",
        "username": "KrzysFR",
        "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
        "created_at": "2019-12-12T16:47:38.481Z",
        "cooked": "<aside class=\"quote no-group\" data-username=\"alloc\" data-post=\"2\" data-topic=\"1833\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/alloc/48/9_2.png\" class=\"avatar\"> alloc:</div>\n<blockquote>\n<p>I believe the idea is that if your transaction ever reads one of these keys, then it is assumed that there is some logic error, so one can\u2019t rely on the value one computed. I\u2019m\u2026not sure that\u2019s necessarily correct all of the time, and it\u2019s also perhaps I\u2019m missing something in the rationale. Perhaps <a class=\"mention\" href=\"/u/evan\">@Evan</a> has more on that?</p>\n</blockquote>\n</aside>\n<p>My thinking is if nobody checks the error code when doing the read-after-changed, then the transaction handler will fail with a non-retryable error so the layer developer will notice the issue.</p>\n<p>But if the layer developer DOES try and catch that specific code, and continues up until commit, maybe it should be allowed? The only way for the commit to throw that error is if a read failed but was caught and the error ignored. Wouldn\u2019t this be a hint that the layer developer is OK with it?</p>\n<p>I can see that logic for any random key, but maybe, specifically for the metadataVersion key, there could be an exception to the rule, or maybe the layer must set a transaction option if you want an explicit opt-out of this safety check ?</p>\n<aside class=\"quote no-group\" data-username=\"alloc\" data-post=\"2\" data-topic=\"1833\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/alloc/48/9_2.png\" class=\"avatar\"> alloc:</div>\n<blockquote>\n<p>Yeah, I suspect it\u2019s impossible (for certain definitions of compose) without either bubbling down this dirty versionstamp protection to either the bindings or to some kind of common library that is shared by all layers.</p>\n</blockquote>\n</aside>\n<p>I\u2019ve attempted to move the logic in the binding itself, and I\u2019m getting something that looks a bit more usable:</p>\n<p>The following test:</p>\n<pre data-code-wrap=\"csharp\"><code class=\"lang-csharp\">await logged.ReadWriteAsync(async tr =&gt;\n{\n\t// We can read the version before\n\tvar before = await tr.GetMetadataVersionAsync();\n\tLog($\"Before: {before}\");\n\tAssert.That(before, Is.Not.Null);\n\n\t// Another read attempt should return the cached value\n\tvar cached = await tr.GetMetadataVersionAsync();\n\tLog($\"Cached: {before}\");\n\tAssert.That(cached, Is.Not.Null.And.EqualTo(before));\n\n\t// change the version from inside the transaction\n\ttr.TouchMetadataVersion();\n\n\t// we should not be able to get the version anymore (should return null)\n\tvar after = await tr.GetMetadataVersionAsync();\n\tLog($\"After: {after}\");\n\tAssert.That(after, Is.Null, \"Should not be able to get the version right after changing it from the same transaction.\");\n\n}, this.Cancellation);\n\n</code></pre>\n<p>Produces the following result and log:</p>\n<pre><code class=\"lang-plaintext\">Before: @5626280078355-0\nCached: @5626280078355-0\nAfter: \n\nTransaction #14 (read/write, 5 operations, '#' = 0.5 ms, started 16:34:48.8935839Z, ended 16:34:48.8968885Z)\n\u250c  oper. \u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500 start \u2500\u2500\u2500\u2500 end \u2500\u2500 duration \u2500\u2500\u252c\u2500 sent  recv \u2510\n\u2502 0   G  \u2502 $      \u2502 T+  0.003 ~   0.438 (    435 \u00b5s) \u2502             \u2502 Get &lt;FF&gt;/metadataVersion =&gt; @5625762147352-0\n\u2502 1   G  \u2502 `      \u2502 T+  0.455 ~   0.456 (      1 \u00b5s) \u2502             \u2502 Get &lt;FF&gt;/metadataVersion =&gt; @5625762147352-0\n\u2502 2   a  \u2502 `      \u2502 T+  0.491 ~   0.497 (      6 \u00b5s) \u2502    31       \u2502 Atomic_VersionStampedValue &lt;FF&gt;/metadataVersion, &lt;00 00 00 00 00 00 00 00 00 00&gt;\n\u2502 3   G  \u2502 `      \u2502 T+  0.497 ~   0.498 (      1 \u00b5s) \u2502             \u2502 Get &lt;FF&gt;/metadataVersion =&gt; &lt;null&gt;\n\u2502 4   Co\u00b0\u2502 .##### \u2502 T+  0.502 ~   3.287 (  2,784 \u00b5s) \u2502             \u2502 Commit\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt; Committed 31 bytes in 3.304 ms and 1 attempt(s)\n</code></pre>\n<p>The first read is passed through to the native binding, the second read is cached by the .NET binding (no native interop), and the last read attempt after the change is dropped by the binding and null is returned instead. That way, the native binding never sees the last read, and commit won\u2019t fail.</p>\n<p>I\u2019m also using a lock to serialize the atomic operation and the async read, hopefully this should not be racy, but I can\u2019t prove it easily. I hope that slowdown in the network thread won\u2019t mean that I\u2019m locking the transaction for too long!</p>",
        "post_number": 3,
        "post_type": 1,
        "posts_count": 7,
        "updated_at": "2019-12-12T16:48:31.453Z",
        "reply_count": 0,
        "reply_to_post_number": null,
        "quote_count": 1,
        "incoming_link_count": 0,
        "reads": 32,
        "readers_count": 31,
        "score": 6.4,
        "yours": false,
        "topic_id": 1833,
        "topic_slug": "cannot-commit-transaction-that-reads-the-metadataversion-key-after-changing-it",
        "display_username": "Christophe Chevalier",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 53,
        "hidden": false,
        "trust_level": 2,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/cannot-commit-transaction-that-reads-the-metadataversion-key-after-changing-it/1833/3",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 5812,
        "name": "Christophe Chevalier",
        "username": "KrzysFR",
        "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
        "created_at": "2019-12-12T18:31:47.078Z",
        "cooked": "<aside class=\"quote no-group\" data-username=\"alloc\" data-post=\"2\" data-topic=\"1833\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/alloc/48/9_2.png\" class=\"avatar\"> alloc:</div>\n<blockquote>\n<p>I think one could actually patch the race by: (1) setting <code>dirtyMetaDataVersionStamp</code> to <code>true</code> and actually setting the key in one synchronized block (or critical section or what have you) and (2) checking the value of the key and then spawning the future to read the key in another synchronized block (but not waiting on the future necessarily). I think that would work, but it depends on the FDB operation being placed onto the network thread before returning, which I think is true of the client. (So then if a write to the meta-data version key comes in while a read is outstanding, it will be applied after the read completes. Or I think those are the semantics without having actually tested them.)</p>\n</blockquote>\n</aside>\n<p>So, if I understand well, the logic in <code>setMetadataVersionStamp()</code> would be:</p>\n<pre><code class=\"lang-auto\">lock {\n    if (dirtyMetaDataVersionStamp) return; // already done!\n\n    // set the flag\n    dirtyMetaDataVersionStamp  = true;\n\n    // start an async read, but we do not care for the result\n    tr.getAsync(MetadataVersionKey).ignoreResult();\n\n    // change the version\n    tr.setVersionstampedValue(MetadataVersionKey, MetadataVersionValue);\n}\n</code></pre>\n<p>And in <code>getMetadataVersionStamp()</code>:</p>\n<pre data-code-wrap=\"C\"><code class=\"lang-C\">future = null;\nlock {\n    if (dirtyMetaDataVersionStamp) return null;\n    // start the async read inside the lock\n    future = tr.getAsync(MetadataVersionKey);\n}\n// wait for result outside the lock\nreturn future.getResult().parseVersionStamp();\n</code></pre>\n<p>I\u2019m not exactly sure then what the fire-and-forget read done in <code>setMetadataVersionStamp()</code> accomplishes?</p>\n<p>Do you mean maybe that calling atomic(\u2026) on a key does not impact any read started previously (but not yet completed), and that\u2019s how we can ensure that a pending call to <code>getMetadataVersionStamp()</code> will not collide with the mutation ?</p>",
        "post_number": 4,
        "post_type": 1,
        "posts_count": 7,
        "updated_at": "2019-12-12T18:31:47.078Z",
        "reply_count": 1,
        "reply_to_post_number": 2,
        "quote_count": 1,
        "incoming_link_count": 0,
        "reads": 26,
        "readers_count": 25,
        "score": 10.2,
        "yours": false,
        "topic_id": 1833,
        "topic_slug": "cannot-commit-transaction-that-reads-the-metadataversion-key-after-changing-it",
        "display_username": "Christophe Chevalier",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 53,
        "hidden": false,
        "trust_level": 2,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/cannot-commit-transaction-that-reads-the-metadataversion-key-after-changing-it/1833/4",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 5813,
        "name": "Alec Grieser",
        "username": "alloc",
        "avatar_template": "/user_avatar/forums.foundationdb.org/alloc/{size}/9_2.png",
        "created_at": "2019-12-12T19:02:03.120Z",
        "cooked": "<aside class=\"quote no-group\" data-username=\"KrzysFR\" data-post=\"4\" data-topic=\"1833\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/krzysfr/48/43_2.png\" class=\"avatar\"> KrzysFR:</div>\n<blockquote>\n<p>I\u2019m not exactly sure then what the fire-and-forget read done in <code>setMetadataVersionStamp()</code> accomplishes?</p>\n</blockquote>\n</aside>\n<p>Oh, sorry. I only meant to imply that the \u201cget\u201d request just needs to be in the same critical section as the read of <code>dirtyMetaDataVersionStamp</code> in the <code>getMetaDataVersionStamp()</code> method. I think that\u2019s necessary basically so that one never calls <code>setVersionstampedValue</code> between the read of the variable and the read of the key. But you shouldn\u2019t need to do any reads in the <code>set</code> method.</p>\n<aside class=\"quote no-group\" data-username=\"KrzysFR\" data-post=\"4\" data-topic=\"1833\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/krzysfr/48/43_2.png\" class=\"avatar\"> KrzysFR:</div>\n<blockquote>\n<p>Do you mean maybe that calling atomic(\u2026) on a key does not impact any read started previously (but not yet completed), and that\u2019s how we can ensure that a pending call to <code>getMetadataVersionStamp()</code> will not collide with the mutation ?</p>\n</blockquote>\n</aside>\n<p>Right, yeah, that was the idea. I think that the way FDB serializes operations onto the network thread, the read for the key will always be executed before the atomic operation as long as <code>.get()</code> is called before <code>.setVersionstampedValue</code>, and I believe you\u2019ll get the value back prior to calling <code>.setVersionstampedValue</code>. But it would be worth testing, etc.</p>",
        "post_number": 5,
        "post_type": 1,
        "posts_count": 7,
        "updated_at": "2019-12-12T19:02:03.120Z",
        "reply_count": 1,
        "reply_to_post_number": 4,
        "quote_count": 1,
        "incoming_link_count": 0,
        "reads": 26,
        "readers_count": 25,
        "score": 10.2,
        "yours": false,
        "topic_id": 1833,
        "topic_slug": "cannot-commit-transaction-that-reads-the-metadataversion-key-after-changing-it",
        "display_username": "Alec Grieser",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 8,
        "hidden": false,
        "trust_level": 4,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/cannot-commit-transaction-that-reads-the-metadataversion-key-after-changing-it/1833/5",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 5818,
        "name": "Christophe Chevalier",
        "username": "KrzysFR",
        "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
        "created_at": "2019-12-13T10:12:45.430Z",
        "cooked": "<aside class=\"quote no-group\" data-username=\"alloc\" data-post=\"5\" data-topic=\"1833\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/alloc/48/9_2.png\" class=\"avatar\"> alloc:</div>\n<blockquote>\n<p>I only meant to imply that the \u201cget\u201d request just needs to be in the same critical section as the read of <code>dirtyMetaDataVersionStamp</code> in the <code>getMetaDataVersionStamp()</code> method</p>\n</blockquote>\n</aside>\n<p>So the correct way to deal with such versionstamps would look like, in pseudo code:</p>\n<pre><code class=\"lang-auto\">void setMetadataVersionStamp() {\n    lock(...) {\n        if (self.dirtyMetaDataVersionStamp) return; // already done!\n\n        // prohibit this transaction from reading the key again\n        self.dirtyMetaDataVersionStamp = true;\n\n        // change the version\n        self.setVersionstampedValue(MetadataVersionKey, MetadataVersionValue);\n    }\n}\n\nversionstamp getMetadataVersionStamp() {\n    future = null;\n    lock(...) {\n        // don't do it if it has already been changed!\n        if (self.dirtyMetaDataVersionStamp) return null;\n        // start the async read inside the lock\n        future = self.getAsync(MetadataVersionKey);\n    }\n    // wait for result outside the lock\n    return future.getResult().parseVersionStamp();\n}\n</code></pre>\n<p>I\u2019m also thinking that the issue is not specific to the <code>\\xff/metadataVersion</code> key. Basically any layer wanting to implement its own cache will probably need a verisonstamped key to track changes to its own schema, and it will be confronted to the very same issue. This means that this method should be made generic and accept a \u2018key\u2019 argument (default value meaning the global metadataVersion key), and instead of a single boolean flag, should have a map of keys that have been marked as \u201ctombstoned\u201d \u2026</p>\n<p>Looks like a lot of memory allocation just to protect against the commit failing!</p>\n<aside class=\"quote no-group\" data-username=\"alloc\" data-post=\"5\" data-topic=\"1833\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/alloc/48/9_2.png\" class=\"avatar\"> alloc:</div>\n<blockquote>\n<p>Right, yeah, that was the idea. I think that the way FDB serializes operations onto the network thread, the read for the key will always be executed before the atomic operation as long as <code>.get()</code> is called before <code>.setVersionstampedValue</code> , and I believe you\u2019ll get the value back prior to calling <code>.setVersionstampedValue</code> . But it would be worth testing, etc.</p>\n</blockquote>\n</aside>\n<p>I think I need to write a bunch of unit tests exploring the limits of what happens when concurrent reads/writes happen on the same transaction, especially when involving versionstamps.</p>",
        "post_number": 6,
        "post_type": 1,
        "posts_count": 7,
        "updated_at": "2019-12-14T14:17:54.069Z",
        "reply_count": 0,
        "reply_to_post_number": 5,
        "quote_count": 1,
        "incoming_link_count": 0,
        "reads": 25,
        "readers_count": 24,
        "score": 5.0,
        "yours": false,
        "topic_id": 1833,
        "topic_slug": "cannot-commit-transaction-that-reads-the-metadataversion-key-after-changing-it",
        "display_username": "Christophe Chevalier",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 2,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 53,
        "hidden": false,
        "trust_level": 2,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/cannot-commit-transaction-that-reads-the-metadataversion-key-after-changing-it/1833/6",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 5819,
        "name": "Christophe Chevalier",
        "username": "KrzysFR",
        "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
        "created_at": "2019-12-13T13:23:15.818Z",
        "cooked": "<p>I added a generic API to deal with versionstamped metadataversion keys, which if called with no key will simply read \\xff/metadataVersion instead, and it helps layers build a caching infrastructure without having to duplicate all the logic above.</p>\n<p>The test creates two versionstamped keys Foo, Bar, and a third key Baz that does not exist yet. The transaction reads all 3 keys, mutate the key Foo, and reads all 3 keys again. Only the key Foo will return null, the other 2 are still using the cached result.</p>\n<p>This API serves two purposes:</p>\n<ul>\n<li>Prevent the application developer from nuking the transaction and having to implement complex logic everywhere</li>\n<li>Add a cache for these keys that does not need to call into the native binding evertime (JNI call for Java, Interop call for .NET, etc\u2026) which can speed things up a bit.</li>\n</ul>\n<p>I think that the second point alone can justify the existence of this API, even if the behavior of the fdb binding changes in the future regarding commits failing with 1036.</p>\n<p>Only downside: if the application developer calls the regular Get(\u2026) / GetRange(\u2026) API to read these keys, then the code will fail with 1036 error. Hopefully there will be some documentation somewhere that explains the situation and the workaround (using the dedicated binding API) !</p>\n<p>The following unit tests:</p>\n<pre><code class=\"lang-auto\">// changing the metadata version and then reading it back from the same transaction CANNOT WORK!\nawait logged.ReadWriteAsync(async tr =&gt;\n{\n\n\t// Read all three keys before\n\n\tvar before1 = await tr.GetMetadataVersionAsync(foo);\n\tLog($\"BeforeFoo: {before1}\");\n\tAssert.That(before1, Is.Not.Null);\n\n\tvar before2 = await tr.GetMetadataVersionAsync(bar);\n\tLog($\"BeforeBar: {before2}\");\n\tAssert.That(before2, Is.Not.Null.And.Not.EqualTo(before1));\n\n\tvar before3 = await tr.GetMetadataVersionAsync(baz);\n\tLog($\"BeforeBaz: {before3}\");\n\tAssert.That(before3, Is.EqualTo(new VersionStamp()));\n\n\t// Change the version of first key from inside the transaction\n\n\ttr.TouchMetadataVersionKey(foo);\n\n\t// Read all three keys again\n\n\tvar after1 = await tr.GetMetadataVersionAsync(foo);\n\tLog($\"AfterFoo: {after1}\");\n\tAssert.That(after1, Is.Null, \"Should not be able to get the version right after changing it from the same transaction.\");\n\n\tvar after2 = await tr.GetMetadataVersionAsync(bar);\n\tLog($\"AfterBar: {after2}\");\n\tAssert.That(after2, Is.Not.Null.And.EqualTo(before2));\n\n\tvar after3 = await tr.GetMetadataVersionAsync(baz);\n\tLog($\"AfterBaz: {after3}\");\n\tAssert.That(after3, Is.EqualTo(new VersionStamp()));\n\n}, this.Cancellation);\n</code></pre>\n<p>Produces the following result:</p>\n<pre><code class=\"lang-auto\">BeforeFoo: @5700013585814-0\nBeforeBar: @5700013521295-0\nBeforeBaz: @0-0\nAfterFoo: \nAfterBar: @5700013521295-0\nAfterBaz: @0-0\n\nTransaction #7 (read/write, 8 operations, '#' = 0.5 ms, started 13:12:21.2760796Z, ended 13:12:21.2800773Z)\n\u250c  oper. \u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500 start \u2500\u2500\u2500\u2500 end \u2500\u2500 duration \u2500\u2500\u252c\u2500 sent  recv \u2510\n\u2502 0   G  \u2502 #       \u2502 T+  0.003 ~   0.506 (    503 \u00b5s) \u2502     9    10 \u2502 Get &lt;02&gt;TEST&lt;00&gt;Foo =&gt; @5700013585814-0\n\u2502 1   G  \u2502 `:      \u2502 T+  0.516 ~   0.613 (     97 \u00b5s) \u2502     9    10 \u2502 Get &lt;02&gt;TEST&lt;00&gt;Bar =&gt; @5700013521295-0\n\u2502 2   G  \u2502 _:      \u2502 T+  0.632 ~   0.724 (     92 \u00b5s) \u2502     9    10 \u2502 Get &lt;02&gt;TEST&lt;00&gt;Baz =&gt; @0-0\n\u2502 3   a  \u2502 _`      \u2502 T+  0.735 ~   0.741 (      6 \u00b5s) \u2502    23       \u2502 Atomic_VersionStampedValue &lt;02&gt;TEST&lt;00&gt;Foo, &lt;00 00 00 00 00 00 00 00 00 00&gt;\n\u2502 4   G  \u2502 _`      \u2502 T+  0.742 ~   0.743 (      1 \u00b5s) \u2502     9    10 \u2502 Get &lt;02&gt;TEST&lt;00&gt;Foo =&gt; &lt;null&gt;\n\u2502 5   G  \u2502 _`      \u2502 T+  0.745 ~   0.746 (      1 \u00b5s) \u2502     9    10 \u2502 Get &lt;02&gt;TEST&lt;00&gt;Bar =&gt; @5700013521295-0\n\u2502 6   G  \u2502 _`      \u2502 T+  0.756 ~   0.757 (      1 \u00b5s) \u2502     9    10 \u2502 Get &lt;02&gt;TEST&lt;00&gt;Baz =&gt; @0-0\n\u2502 7   Co\u00b0\u2502 _=##### \u2502 T+  0.765 ~   3.671 (  2,907 \u00b5s) \u2502             \u2502 Commit\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt; Read 60 bytes and Committed 23 bytes in 3.682 ms and 1 attempt(s)\n</code></pre>",
        "post_number": 7,
        "post_type": 1,
        "posts_count": 7,
        "updated_at": "2019-12-13T14:11:35.366Z",
        "reply_count": 0,
        "reply_to_post_number": null,
        "quote_count": 0,
        "incoming_link_count": 2,
        "reads": 23,
        "readers_count": 22,
        "score": 14.6,
        "yours": false,
        "topic_id": 1833,
        "topic_slug": "cannot-commit-transaction-that-reads-the-metadataversion-key-after-changing-it",
        "display_username": "Christophe Chevalier",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 2,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 53,
        "hidden": false,
        "trust_level": 2,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/cannot-commit-transaction-that-reads-the-metadataversion-key-after-changing-it/1833/7",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      }
    ],
    "stream": [
      5801,
      5809,
      5811,
      5812,
      5813,
      5818,
      5819
    ]
  },
  "timeline_lookup": [
    [
      1,
      2141
    ],
    [
      2,
      2140
    ],
    [
      7,
      2139
    ]
  ],
  "suggested_topics": [],
  "tags": [],
  "tags_descriptions": {},
  "fancy_title": "Cannot commit transaction that reads the metadataVersion key after changing it",
  "id": 1833,
  "title": "Cannot commit transaction that reads the metadataVersion key after changing it",
  "posts_count": 7,
  "created_at": "2019-12-11T22:52:33.816Z",
  "views": 1297,
  "reply_count": 3,
  "like_count": 0,
  "last_posted_at": "2019-12-13T13:23:15.818Z",
  "visible": true,
  "closed": false,
  "archived": false,
  "has_summary": false,
  "archetype": "regular",
  "slug": "cannot-commit-transaction-that-reads-the-metadataversion-key-after-changing-it",
  "category_id": 7,
  "word_count": 3222,
  "deleted_at": null,
  "user_id": 53,
  "featured_link": null,
  "pinned_globally": false,
  "pinned_at": null,
  "pinned_until": null,
  "image_url": null,
  "slow_mode_seconds": 0,
  "draft": null,
  "draft_key": "topic_1833",
  "draft_sequence": null,
  "unpinned": null,
  "pinned": false,
  "current_post_number": 1,
  "highest_post_number": 7,
  "deleted_by": null,
  "actions_summary": [
    {
      "id": 4,
      "count": 0,
      "hidden": false,
      "can_act": false
    },
    {
      "id": 8,
      "count": 0,
      "hidden": false,
      "can_act": false
    },
    {
      "id": 10,
      "count": 0,
      "hidden": false,
      "can_act": false
    },
    {
      "id": 7,
      "count": 0,
      "hidden": false,
      "can_act": false
    }
  ],
  "chunk_size": 20,
  "bookmarked": false,
  "topic_timer": null,
  "message_bus_last_id": 0,
  "participant_count": 2,
  "show_read_indicator": false,
  "thumbnails": null,
  "slow_mode_enabled_until": null,
  "tags_disable_ads": false,
  "related_topics": [
    {
      "fancy_title": "Implementing VersionStamps in bindings",
      "id": 250,
      "title": "Implementing VersionStamps in bindings",
      "slug": "implementing-versionstamps-in-bindings",
      "posts_count": 25,
      "reply_count": 18,
      "highest_post_number": 25,
      "image_url": null,
      "created_at": "2018-04-24T19:05:11.830Z",
      "last_posted_at": "2018-05-09T18:14:10.990Z",
      "bumped": true,
      "bumped_at": "2018-05-09T18:14:10.990Z",
      "archetype": "regular",
      "unseen": false,
      "pinned": false,
      "unpinned": null,
      "visible": true,
      "closed": false,
      "archived": false,
      "bookmarked": null,
      "liked": null,
      "tags": [],
      "tags_descriptions": {},
      "like_count": 3,
      "views": 5417,
      "category_id": 8,
      "featured_link": null,
      "has_accepted_answer": false,
      "posters": [
        {
          "extras": null,
          "description": "Original Poster",
          "user": {
            "id": 53,
            "username": "KrzysFR",
            "name": "Christophe Chevalier",
            "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
            "trust_level": 2
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 156,
            "username": "spullara",
            "name": "Sam Pullara",
            "avatar_template": "/user_avatar/forums.foundationdb.org/spullara/{size}/125_2.png",
            "trust_level": 2
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 12,
            "username": "ajbeamon",
            "name": "A.J. Beamon",
            "avatar_template": "/user_avatar/forums.foundationdb.org/ajbeamon/{size}/13_2.png",
            "admin": true,
            "trust_level": 4
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 120,
            "username": "josephg",
            "name": "Seph Gentle",
            "avatar_template": "/user_avatar/forums.foundationdb.org/josephg/{size}/84_2.png",
            "trust_level": 2
          }
        },
        {
          "extras": "latest",
          "description": "Most Recent Poster",
          "user": {
            "id": 8,
            "username": "alloc",
            "name": "Alec Grieser",
            "avatar_template": "/user_avatar/forums.foundationdb.org/alloc/{size}/9_2.png",
            "trust_level": 4
          }
        }
      ]
    },
    {
      "fancy_title": "A few design-pattern + check-my-understanding questions",
      "id": 1153,
      "title": "A few design-pattern + check-my-understanding questions",
      "slug": "a-few-design-pattern-check-my-understanding-questions",
      "posts_count": 10,
      "reply_count": 6,
      "highest_post_number": 10,
      "image_url": null,
      "created_at": "2019-02-19T15:18:58.329Z",
      "last_posted_at": "2019-02-21T19:51:53.686Z",
      "bumped": true,
      "bumped_at": "2019-02-21T19:51:53.686Z",
      "archetype": "regular",
      "unseen": false,
      "pinned": false,
      "unpinned": null,
      "visible": true,
      "closed": false,
      "archived": false,
      "bookmarked": null,
      "liked": null,
      "tags": [],
      "tags_descriptions": {},
      "like_count": 1,
      "views": 2273,
      "category_id": 7,
      "featured_link": null,
      "has_accepted_answer": false,
      "posters": [
        {
          "extras": null,
          "description": "Original Poster",
          "user": {
            "id": 519,
            "username": "JamesThompson",
            "name": "James Thompson",
            "avatar_template": "https://avatars.discourse-cdn.com/v4/letter/j/c67d28/{size}.png",
            "trust_level": 1
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 173,
            "username": "jkominek",
            "name": "Jay Kominek",
            "avatar_template": "/user_avatar/forums.foundationdb.org/jkominek/{size}/140_2.png",
            "trust_level": 2
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 12,
            "username": "ajbeamon",
            "name": "A.J. Beamon",
            "avatar_template": "/user_avatar/forums.foundationdb.org/ajbeamon/{size}/13_2.png",
            "admin": true,
            "trust_level": 4
          }
        },
        {
          "extras": "latest",
          "description": "Most Recent Poster",
          "user": {
            "id": 53,
            "username": "KrzysFR",
            "name": "Christophe Chevalier",
            "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
            "trust_level": 2
          }
        }
      ]
    },
    {
      "fancy_title": "&ldquo;Read or wrote an unreadable key&rdquo; when read and then write versionstamp value",
      "id": 2301,
      "title": "\"Read or wrote an unreadable key\" when read and then write versionstamp value",
      "slug": "read-or-wrote-an-unreadable-key-when-read-and-then-write-versionstamp-value",
      "posts_count": 2,
      "reply_count": 0,
      "highest_post_number": 2,
      "image_url": null,
      "created_at": "2020-08-22T22:36:53.054Z",
      "last_posted_at": "2020-08-23T00:50:06.076Z",
      "bumped": true,
      "bumped_at": "2020-08-23T00:50:06.076Z",
      "archetype": "regular",
      "unseen": false,
      "pinned": false,
      "unpinned": null,
      "visible": true,
      "closed": false,
      "archived": false,
      "bookmarked": null,
      "liked": null,
      "tags": [
        "bindings"
      ],
      "tags_descriptions": {},
      "like_count": 0,
      "views": 706,
      "category_id": 7,
      "featured_link": null,
      "has_accepted_answer": false,
      "posters": [
        {
          "extras": "latest single",
          "description": "Original Poster, Most Recent Poster",
          "user": {
            "id": 393,
            "username": "ex3ndr",
            "name": "Steve Korshakov",
            "avatar_template": "/user_avatar/forums.foundationdb.org/ex3ndr/{size}/389_2.png",
            "trust_level": 2
          }
        }
      ]
    },
    {
      "fancy_title": "Deferred value checks as an alternative to the metadataVersion key for caching in layers",
      "id": 2123,
      "title": "Deferred value checks as an alternative to the metadataVersion key for caching in layers",
      "slug": "deferred-value-checks-as-an-alternative-to-the-metadataversion-key-for-caching-in-layers",
      "posts_count": 3,
      "reply_count": 1,
      "highest_post_number": 3,
      "image_url": null,
      "created_at": "2020-05-14T13:44:27.861Z",
      "last_posted_at": "2020-05-26T14:32:11.872Z",
      "bumped": true,
      "bumped_at": "2020-05-26T17:43:34.902Z",
      "archetype": "regular",
      "unseen": false,
      "pinned": false,
      "unpinned": null,
      "visible": true,
      "closed": false,
      "archived": false,
      "bookmarked": null,
      "liked": null,
      "tags": [],
      "tags_descriptions": {},
      "like_count": 0,
      "views": 849,
      "category_id": 5,
      "featured_link": null,
      "has_accepted_answer": false,
      "posters": [
        {
          "extras": "latest single",
          "description": "Original Poster, Most Recent Poster",
          "user": {
            "id": 53,
            "username": "KrzysFR",
            "name": "Christophe Chevalier",
            "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
            "trust_level": 2
          }
        }
      ]
    },
    {
      "fancy_title": "Should mutations performed via fdbcli always update the \\xff/metadataVersion key?",
      "id": 2093,
      "title": "Should mutations performed via fdbcli always update the \\xff/metadataVersion key?",
      "slug": "should-mutations-performed-via-fdbcli-always-update-the-xff-metadataversion-key",
      "posts_count": 6,
      "reply_count": 2,
      "highest_post_number": 6,
      "image_url": null,
      "created_at": "2020-04-29T11:39:06.923Z",
      "last_posted_at": "2020-05-14T13:46:08.081Z",
      "bumped": true,
      "bumped_at": "2020-05-14T13:46:08.081Z",
      "archetype": "regular",
      "unseen": false,
      "pinned": false,
      "unpinned": null,
      "visible": true,
      "closed": false,
      "archived": false,
      "bookmarked": null,
      "liked": null,
      "tags": [],
      "tags_descriptions": {},
      "like_count": 0,
      "views": 938,
      "category_id": 7,
      "featured_link": null,
      "has_accepted_answer": false,
      "posters": [
        {
          "extras": "latest",
          "description": "Original Poster, Most Recent Poster",
          "user": {
            "id": 53,
            "username": "KrzysFR",
            "name": "Christophe Chevalier",
            "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
            "trust_level": 2
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 15,
            "username": "markus.pilman",
            "name": "Markus Pilman",
            "avatar_template": "/user_avatar/forums.foundationdb.org/markus.pilman/{size}/379_2.png",
            "admin": true,
            "trust_level": 4
          }
        }
      ]
    }
  ],
  "summarizable": false,
  "can_vote": false,
  "vote_count": 0,
  "user_voted": false,
  "discourse_zendesk_plugin_zendesk_id": null,
  "discourse_zendesk_plugin_zendesk_url": "https://your-url.zendesk.com/agent/tickets/",
  "details": {
    "can_edit": false,
    "notification_level": 1,
    "participants": [
      {
        "id": 53,
        "username": "KrzysFR",
        "name": "Christophe Chevalier",
        "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
        "post_count": 5,
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_color": null,
        "flair_bg_color": null,
        "flair_group_id": null,
        "trust_level": 2
      },
      {
        "id": 8,
        "username": "alloc",
        "name": "Alec Grieser",
        "avatar_template": "/user_avatar/forums.foundationdb.org/alloc/{size}/9_2.png",
        "post_count": 2,
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_color": null,
        "flair_bg_color": null,
        "flair_group_id": null,
        "trust_level": 4
      }
    ],
    "created_by": {
      "id": 53,
      "username": "KrzysFR",
      "name": "Christophe Chevalier",
      "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png"
    },
    "last_poster": {
      "id": 53,
      "username": "KrzysFR",
      "name": "Christophe Chevalier",
      "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png"
    },
    "links": [
      {
        "url": "https://github.com/apple/foundationdb/issues/2436",
        "title": "Attempt to read metadataVersion key in snapshot isolation fails with `Read or wrote an unreadable key` after changing it \u00b7 Issue #2436 \u00b7 apple/foundationdb \u00b7 GitHub",
        "internal": false,
        "attachment": false,
        "reflection": false,
        "clicks": 8,
        "user_id": 53,
        "domain": "github.com",
        "root_domain": "github.com"
      },
      {
        "url": "https://forums.foundationdb.org/t/how-to-safely-add-a-metadata-caching-layer-on-top-of-existing-layers/1809/2",
        "title": "How to safely add a metadata caching \"layer\" on top of existing layers?",
        "internal": true,
        "attachment": false,
        "reflection": true,
        "clicks": 1,
        "user_id": 53,
        "domain": "forums.foundationdb.org",
        "root_domain": "foundationdb.org"
      },
      {
        "url": "https://github.com/FoundationDB/fdb-record-layer/blob/2953315650f0c426a32bc4486f7e0596185a9d40/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBRecordContext.java#L879",
        "title": "fdb-record-layer/FDBRecordContext.java at 2953315650f0c426a32bc4486f7e0596185a9d40 \u00b7 FoundationDB/fdb-record-layer \u00b7 GitHub",
        "internal": false,
        "attachment": false,
        "reflection": false,
        "clicks": 1,
        "user_id": 53,
        "domain": "github.com",
        "root_domain": "github.com"
      }
    ]
  },
  "bookmarks": []
}