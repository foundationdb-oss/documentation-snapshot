{
  "post_stream": {
    "posts": [
      {
        "id": 889,
        "name": "Christophe Chevalier",
        "username": "KrzysFR",
        "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
        "created_at": "2018-05-07T08:18:42.982Z",
        "cooked": "<p>I have a long running service that connects to a FoundationDB cluster, and I was wondering what would be the best strategy to emulate a global <code>on_connection_state_changed(previous_state, new_state)</code> event, in order to support the Circuit Breaker Pattern at the application level.</p>\n<p>After some experience with FDB, I have added default timeouts/retry limits to protect against failure of the cluster while the application is running, but there is still an issue when the application starts while the cluster is not available (network issue, fdb.cluster outdated, less than X% disk space available globally, \u2026), especially for all the init code that needs run before everything else, and will use the Directory Layer to open all the subspaces required by all the layers.</p>\n<p>When using traditional SQL servers, the code usually does not need to go through that initialization step (schema is handled by the server), and only has to deal with the question <em>\u201cwhat is the probability that the the database is available now?\u201d</em>.</p>\n<p>But with FDB and the Directory Layer, the question becomes <em>\u201cwhat is the probability that the database is available now, and that the key prefixes for all my subspaces are still valid?\u201d</em>. (They could change if the cluster was down due to a full data restore and just came back online, which has happened to me in the past and caused havoc everywhere!).</p>\n<p>Having an event that triggers on state change, I could re-open all the subspaces in use, and be assured that I don\u2019t pollute the database with old key prefixes.</p>\n<p>My first though would be to have a thread that continuously tries to read a key from the database, to detect failure and simulate an internal Open/Close state for the circuit breaker, but this has a few drawbacks:</p>\n<ul>\n<li>This is polling which consumes a lot of resources for nothing (especially on a farm of multiple clients all polling the same key)</li>\n<li>When the cluster falls, I would have to wait for the read timeout to expire to officially declare the cluster unreachable, which will require another Magic Number for the timeout value (1 sec? 5 sec?..)</li>\n<li>When the cluster goes back online, I will also need to wait on average half the polling interval to resume operations.</li>\n<li>That\u2019s another thread to spin up, monitor, and wait for it to abort when stopping the application.</li>\n</ul>\n<p>I was thinking that the client library already does this sort of monitoring of the status of the cluster, because it needs to maintain connection to the proxies, storage nodes etc\u2026 and probably already have a \u201cavailable/unavailable\u201d state internally. Would there be a way to tap into this and get notified somehow when the client change from one state to another?</p>\n<p>It could be something that looks like a Watch on a client-only virtual key in the <code>\\xFF</code> system keyspace? The key could store an enum value, and the client could watch the value change.</p>\n<p>The desired properties of this are:</p>\n<ul>\n<li>reduce the cpu and network overhead by not having to repeatedly poll a key in the general keyspace</li>\n<li>reduce the delay to detect failure/resolution</li>\n<li>provide a global Circuit Breaker that can be used by the application to not pay the timeout cost when possible.</li>\n<li>provide a generic API that the application can plug into for \u201cdata refresh\u201d events.</li>\n</ul>",
        "post_number": 1,
        "post_type": 1,
        "posts_count": 9,
        "updated_at": "2018-05-07T08:32:25.551Z",
        "reply_count": 0,
        "reply_to_post_number": null,
        "quote_count": 0,
        "incoming_link_count": 244,
        "reads": 62,
        "readers_count": 61,
        "score": 1276.4,
        "yours": false,
        "topic_id": 365,
        "topic_slug": "detecting-cluster-availability-transitions-for-long-running-clients",
        "display_username": "Christophe Chevalier",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 2,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [
          {
            "id": 2,
            "count": 2
          }
        ],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 53,
        "hidden": false,
        "trust_level": 2,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/detecting-cluster-availability-transitions-for-long-running-clients/365/1",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null,
        "can_vote": false
      },
      {
        "id": 919,
        "name": "David Scherer",
        "username": "dave",
        "avatar_template": "/user_avatar/forums.foundationdb.org/dave/{size}/89_2.png",
        "created_at": "2018-05-07T21:56:15.260Z",
        "cooked": "<p>As to ACI (but not D) restores specifically breaking your invariants, maybe there is, or should be, a restore lock version key that you could check? Or something specific to the directory layer? I don\u2019t actually think it is impossible to do a restore without clients losing connection to the database. The DB being down <em>really</em> is supposed to be indistinguishable from any other source of latency.</p>\n<p>(This relates also to what I think might be the simplest feature for making metadata read scaling easier in layers, which is a way to add read conflict ranges at a version other than the snapshot version of a transaction. This feature could be used to validate a directory or restore epoch key without doing a read in every transaction)</p>",
        "post_number": 2,
        "post_type": 1,
        "posts_count": 9,
        "updated_at": "2018-05-07T21:56:15.260Z",
        "reply_count": 1,
        "reply_to_post_number": null,
        "quote_count": 0,
        "incoming_link_count": 7,
        "reads": 51,
        "readers_count": 50,
        "score": 50.2,
        "yours": false,
        "topic_id": 365,
        "topic_slug": "detecting-cluster-availability-transitions-for-long-running-clients",
        "display_username": "David Scherer",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 22,
        "hidden": false,
        "trust_level": 1,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/detecting-cluster-availability-transitions-for-long-running-clients/365/2",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 921,
        "name": "Christophe Chevalier",
        "username": "KrzysFR",
        "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
        "created_at": "2018-05-07T22:17:40.924Z",
        "cooked": "<p>After talking with a colleague about this today, I don\u2019t think there is currently a way to guarantee 100% that all directory subspace prefix will be correct without adding at least one read to each transaction (even if to check a version key on the subspace itself). So in practice there would be no such thing as a write-only transaction, and if I need to do at least <em>one</em> read, then atomic operations and versionstamps are less useful, which is a shame.</p>\n<p>This is too much of a cost to pay, in my opinion, for an event that only happens once in a blue moon, as in a \u201csoft\u201d backup/restore at the application level that happens when updating the schema or indexes of a document store, ie: <code>clearrange '' \\xFF</code> followed by bulk inserting everything back in, while some application nodes are still running somewhere (adminsys forgot to kill some processes). This has happened to us multiple times (node not dying immediately because of some thread stuck somewhere, and continuing accepting incoming HTTP traffic).</p>\n<p>If I lower my expectations just a tiny bit, from <em>\u201cit will never corrupt anything but will be slow\u201d</em> down to <em>\u201cat least if it happens, the application will figure it out quickly\u201d</em> then it could be tolerable. I always use Directory Partitions to contain an application\u2019s data, so I could at least register the main partition with a value that is always different, so I\u2019m guaranteed that the new restored content is in a different key subspace that the previous generation, and that way surviving nodes that haven\u2019t rebooted yet would at most add data to the old location, and not break the new one, combined with some polling that detects things in a manner of a few seconds\u2026</p>\n<p>But yes, if there was a way in the future to say \"conflict my transactions if this key (or range of keys) in the Directory Layer has been changed by <em>anyone</em> in the last 5 seconds`, combined with a thread that would check things every 5 seconds, then it would make this a non-issue.</p>\n<p>I would still need a way to detect availability events to speed things up (right after the client is back online, do a check immediately, instead of waiting the remainder of the 5 sec quanta).</p>\n<p>Btw: this is highlighting another issue with the current design of Directory Subspace currently: once they are created with the current prefix for this subspace, and handed to the Layer, then there is no real mean for the Directory Layer to silently update the key prefix to the new value, without some events or subscription by the Layer code\u2026 This is starting to get real messy and ugly, just for the sake of helping prevent major catastrophe in the event of a sysadmin not following the update checklist properly. I need to think about how the API could be changed somehow to allow such scenario, maybe by adding a level of indirection at the subspace level, with \u201cconstant prefix\u201d for manual prefixes, and \u201cdynamic prefix\u201d for subspaces created by a Directory Layer. It would then keep references to such prefixes and have a way to change them from under the Layer\u2019s nose (so to speak). But what if the layer is in a middle of a transaction? <img src=\"https://emoji.discourse-cdn.com/twitter/slight_smile.png?v=5\" title=\":slight_smile:\" class=\"emoji\" alt=\":slight_smile:\"></p>",
        "post_number": 3,
        "post_type": 1,
        "posts_count": 9,
        "updated_at": "2018-05-07T22:17:40.924Z",
        "reply_count": 1,
        "reply_to_post_number": 2,
        "quote_count": 0,
        "incoming_link_count": 0,
        "reads": 50,
        "readers_count": 49,
        "score": 15.0,
        "yours": false,
        "topic_id": 365,
        "topic_slug": "detecting-cluster-availability-transitions-for-long-running-clients",
        "display_username": "Christophe Chevalier",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "reply_to_user": {
          "id": 22,
          "username": "dave",
          "name": "David Scherer",
          "avatar_template": "/user_avatar/forums.foundationdb.org/dave/{size}/89_2.png"
        },
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 53,
        "hidden": false,
        "trust_level": 2,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/detecting-cluster-availability-transitions-for-long-running-clients/365/3",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 924,
        "name": "A.J. Beamon",
        "username": "ajbeamon",
        "avatar_template": "/user_avatar/forums.foundationdb.org/ajbeamon/{size}/13_2.png",
        "created_at": "2018-05-07T23:40:45.059Z",
        "cooked": "<p>Just so I understand, with respect to the directory layer are you referring to the issue of directories being moved or deleted while being used by other clients? It\u2019s certainly true that the current directory layer defers managing the concurrency between directory access and directory modifications to the user and provides no mechanism for the directory objects on the client to synchronize with changes in the database.</p>",
        "post_number": 4,
        "post_type": 1,
        "posts_count": 9,
        "updated_at": "2018-05-07T23:40:45.059Z",
        "reply_count": 1,
        "reply_to_post_number": 3,
        "quote_count": 0,
        "incoming_link_count": 0,
        "reads": 39,
        "readers_count": 38,
        "score": 12.8,
        "yours": false,
        "topic_id": 365,
        "topic_slug": "detecting-cluster-availability-transitions-for-long-running-clients",
        "display_username": "A.J. Beamon",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "reply_to_user": {
          "id": 53,
          "username": "KrzysFR",
          "name": "Christophe Chevalier",
          "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png"
        },
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": true,
        "staff": true,
        "user_id": 12,
        "hidden": false,
        "trust_level": 4,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/detecting-cluster-availability-transitions-for-long-running-clients/365/4",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 943,
        "name": "Christophe Chevalier",
        "username": "KrzysFR",
        "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
        "created_at": "2018-05-08T08:31:15.149Z",
        "cooked": "<p>Yes, there a two things that I\u2019d like to deal with to make my application tolerant against changes in the cluster, either in connectivity (network issues, crashes, \u2026) as well a schema changes that could lead to read or writing data to the wrong place:</p>\n<ol>\n<li>\n<p>Detecting changes in availability as soon as possible, to get rid of the potential timeout if I let transactions discover it themselves. I can use the Circuit Breaker pattern so that requests happening when the cluster is unavailable (for any reason) fail immediately (or use a fallback method), and then have longer timeouts in general (relying on the breaker to react quickly).</p>\n</li>\n<li>\n<p>Protect against changes of prefix in the Directory Layer during some infrequent operations (restore or schema upgrade that have to delete / recreate the whole directory hierarchy) that could happen while some nodes are still running (for all kinds of reasons, mistakes, bugs, \u2026)</p>\n</li>\n</ol>\n<p>Having 1. could be used as a signal to detect major events and pre-emptively recheck the Directory Layer for changes that are caused by a major events.</p>\n<p>But to 100% protect against 2., I would still need to detect changes that did not impact connectivity, such as a script doing a clear_range on all keys, and recreating all the folders (with new prefixes). Then I guess the only way would be to have a to create a conflict range on the last N seconds, combined with a thread that checks for changes in the DL every N seconds as well. I would need a way to identify from the error code that it is the DL who is conflicting and needs refreshing, and not the rest of the transaction.</p>\n<p>Another way of protecting against 2. would be to have some sort of global lock that an upgrade tool could take to \u201cforce\u201d all nodes into an offline state, and then they would wait for the lock to be released to go back \u201conline\u201d and recheck all subspaces.</p>\n<p>But where would I store this key? Since I use partitions and subspaces for everything, the lock key itself would be in a subspace whose prefix could have changed after the migration/restore script did its job.</p>\n<p>I would need a \u201csafe\u201d location outside the sphere of influence of the Directory Layer, with a fixed prefix. Maybe the DL could always reserve a fixed prefix for some global locking subspace, used to protect against chances in the DL itself? (Could be convention based, like 254 is for the DL itself, and for ex, 253 could be pre-reserved for a \u201csystem\u201d subspace with a constant name, that cannot be deleted (or at least will always reuse the same prefix when created?).</p>\n<p><em>note: to clarify, the application will be deployed and maintained by people who are not database experts or even sysadmins, and on some cases don\u2019t really know what they are doing and don\u2019t always follow the checklists. I really need to make it almost fool proof, because mistakes will happen! And in this case it could lead to complete data loss.</em></p>",
        "post_number": 5,
        "post_type": 1,
        "posts_count": 9,
        "updated_at": "2018-05-08T08:31:15.149Z",
        "reply_count": 1,
        "reply_to_post_number": 4,
        "quote_count": 0,
        "incoming_link_count": 1,
        "reads": 38,
        "readers_count": 37,
        "score": 17.6,
        "yours": false,
        "topic_id": 365,
        "topic_slug": "detecting-cluster-availability-transitions-for-long-running-clients",
        "display_username": "Christophe Chevalier",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "reply_to_user": {
          "id": 12,
          "username": "ajbeamon",
          "name": "A.J. Beamon",
          "avatar_template": "/user_avatar/forums.foundationdb.org/ajbeamon/{size}/13_2.png"
        },
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 53,
        "hidden": false,
        "trust_level": 2,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/detecting-cluster-availability-transitions-for-long-running-clients/365/5",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 954,
        "name": "A.J. Beamon",
        "username": "ajbeamon",
        "avatar_template": "/user_avatar/forums.foundationdb.org/ajbeamon/{size}/13_2.png",
        "created_at": "2018-05-08T16:29:51.992Z",
        "cooked": "<aside class=\"quote no-group\" data-username=\"KrzysFR\" data-post=\"5\" data-topic=\"365\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/krzysfr/48/43_2.png\" class=\"avatar\"> KrzysFR:</div>\n<blockquote>\n<p>Having 1. could be used as a signal to detect major events and pre-emptively recheck the Directory Layer for changes that are caused by a major events.</p>\n</blockquote>\n</aside>\n<p>So the idea is to use database availability changes as a signal that somebody may have made substantial changes? That\u2019s an interesting idea, but it sounds like it won\u2019t be sufficient to catch all such major events you\u2019re worried about. And if you do use another mechanism to react to these events, you may no longer need this signal.</p>\n<p>As to being able to fail early, I think that may also be a bit tricky. As Dave said, the database being down is supposed to appear to the client as a (potentially long) source of latency. Sometimes, the database may be \u201cdown\u201d for less than 1 second, in which case you may actually want to hang around and treat it like any other sub-second source of latency. So that raises the question how long should the cluster be down before we trigger this unavailability notification, and the current way to deal with that is with our timeouts. It sounds like the argument you\u2019re making here may involve being able to have distinct timeouts for the database being down vs. other concerns (the database being slow, the transaction conflicting a lot, etc.).</p>\n<aside class=\"quote no-group\" data-username=\"KrzysFR\" data-post=\"5\" data-topic=\"365\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/krzysfr/48/43_2.png\" class=\"avatar\"> KrzysFR:</div>\n<blockquote>\n<p>But to 100% protect against 2., I would still need to detect changes that did not impact connectivity, such as a script doing a clear_range on all keys, and recreating all the folders (with new prefixes). Then I guess the only way would be to have a to create a conflict range on the last N seconds, combined with a thread that checks for changes in the DL every N seconds as well. I would need a way to identify from the error code that it is the DL who is conflicting and needs refreshing, and not the rest of the transaction.</p>\n</blockquote>\n</aside>\n<p>You could potentially use a key inside each directory to track when it was created, with each of your clients storing the value of that key when opening the directory. For example, you could store a key with a versionstamped value inside each directory. You may need to update the value when moving the directory, depending on what your clients are doing with their DirectorySubspaces (and you would also have to recursively change the child directories). I don\u2019t believe directory operations (such as creating new directories and removing directories) will work on DirectorySubspaces that refer to a directory that has been moved, but you should still be able to pack keys with them.</p>\n<p>Clients would then be responsible for reading this key in each transaction that they use the directory. If the value matches what it was when you opened it, then you can proceed to use the directory. If it has changed, then you may need to reopen it. If the key is now missing, the directory has presumably been deleted. If there are concurrent modifications to the directory structure that change this key, then they will cause your transaction to fail.</p>\n<p>The above scheme costs a read for each directory that you access (though you could pull the special keys up to a higher level if you wanted, reducing the number of reads if you are accessing a lot of directories), but it seems like it would protect you from the various events you described.</p>",
        "post_number": 6,
        "post_type": 1,
        "posts_count": 9,
        "updated_at": "2018-05-08T16:29:51.992Z",
        "reply_count": 2,
        "reply_to_post_number": 5,
        "quote_count": 1,
        "incoming_link_count": 0,
        "reads": 32,
        "readers_count": 31,
        "score": 16.4,
        "yours": false,
        "topic_id": 365,
        "topic_slug": "detecting-cluster-availability-transitions-for-long-running-clients",
        "display_username": "A.J. Beamon",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": true,
        "staff": true,
        "user_id": 12,
        "hidden": false,
        "trust_level": 4,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/detecting-cluster-availability-transitions-for-long-running-clients/365/6",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 956,
        "name": "Christophe Chevalier",
        "username": "KrzysFR",
        "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
        "created_at": "2018-05-08T16:46:46.164Z",
        "cooked": "<aside class=\"quote no-group quote-modified\" data-username=\"ajbeamon\" data-post=\"6\" data-topic=\"365\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/ajbeamon/48/13_2.png\" class=\"avatar\"> ajbeamon:</div>\n<blockquote>\n<p>it sounds like the argument you\u2019re making here may involve being able to have distinct timeouts for the database being down vs. other concerns (the database being slow, the transaction conflicting a lot, etc.).</p>\n</blockquote>\n</aside>\n<p>I have users that are actively standing up in front of an appliance, waiting for the little spinner to go away, so I cannot wait 10 or 15 seconds for a \u201ctraditional\u201d timeout. I would need shorter timeouts, but then it will be too trigger happy, and now I\u2019m faced with a magic number that is always too long and too short at the same time.</p>\n<p>The current version or our product uses a SQL database with a Circuit Breaker on top that monitors failures and unusual latency, combined with polling every minute for connectivity to the database. This works well because when a failure happens, we still need 5-10 sec to react, but then the breaker opens and all following requests will be served from a cache, or at least we can push a message \u201csorry this is out of order please wait a moment\u201d to the user. Since it is very unlikely that the database would go down at the exact moment a user would start interacting with the appliance, it means that they either show up to something that works, or is already displaying a \u201cout of order\u201d message with some helpful text. No waiting. And if the issue happens while no-one is watching, we did not waste any time timeouting or polling.</p>\n<p>I need to keep doing that, but if I want to scale to larger server counts, I\u2019m can\u2019t really use frequent polling (client side) to pre-emptively react to db connectivity loses. Also, with more servers and more users, the probability that someone actually uses the appliance while the error condition is starting goes up.</p>\n<p>My idea was that the client library already has to do this sort of things, and the polling here is probably happening at the socket layer with keep alive messages that are send to some coordinator or proxy node. This is probably very efficient. If I would do the same thing at the application level, I would need to probably read a key (or maybe get a read version) which will take more cpu time from the processes (and require more network roundtrips).</p>\n<p>IF the client already does have this internal connected/disconnected/reconnecting state, and if it could be exposed to the application then at least I will not add any overhead to what there currently is.</p>\n<p>The circuit breaker that sits on top could query this state (either on each transaction start or periodically), as well as the regular monitoring of errors / latency.</p>",
        "post_number": 7,
        "post_type": 1,
        "posts_count": 9,
        "updated_at": "2018-05-08T16:46:46.164Z",
        "reply_count": 1,
        "reply_to_post_number": 6,
        "quote_count": 1,
        "incoming_link_count": 0,
        "reads": 27,
        "readers_count": 26,
        "score": 10.4,
        "yours": false,
        "topic_id": 365,
        "topic_slug": "detecting-cluster-availability-transitions-for-long-running-clients",
        "display_username": "Christophe Chevalier",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 53,
        "hidden": false,
        "trust_level": 2,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/detecting-cluster-availability-transitions-for-long-running-clients/365/7",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 957,
        "name": "Christophe Chevalier",
        "username": "KrzysFR",
        "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
        "created_at": "2018-05-08T16:56:27.210Z",
        "cooked": "<aside class=\"quote no-group\" data-username=\"ajbeamon\" data-post=\"6\" data-topic=\"365\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/ajbeamon/48/13_2.png\" class=\"avatar\"> ajbeamon:</div>\n<blockquote>\n<p>Clients would then be responsible for reading this key in each transaction that they use the directory</p>\n</blockquote>\n</aside>\n<p>That\u2019s not really possible for me, because this kills write-only transactions, and EVERY layer has to perform this check, everywhere, every time it does anything to the db. And since this is a read, this is async which also has an impact (at least in C# where the method need to be async as well).</p>\n<p>Like explained above, I don\u2019t need 100% certainty, just to ensure that the probability of if happening it so small that it is acceptable.</p>\n<p>I think that with the current API, the only way would be to create such a key, and then use a watch to detect if it changes, and try to react as soon as possible. The window of opportunity for data corruption would be the time it takes for the watch to trigger, and the callback to pull the fuse (by poisoning the Subspace instance so that it throws whenever someones attempts to use it). Since database instances can also be setup to only see a partition, they would ALSO be poisoned.</p>\n<p>At least, I could \u201cnuke\u201d any node that would have survived, and with proper logging/notification, wait for them to be restarted. (basically, the application could hook such event, and do something like a <em>FailFast(\u2026)</em> to self destruct and get the attention of the sysadmin.</p>\n<p>Ideally, with some new API to create conflict range in the past, then this would be automatically added to each transaction that comes from a database instance tied to a partition, and reduce this window of opportunity even more (maybe down to 0).</p>",
        "post_number": 8,
        "post_type": 1,
        "posts_count": 9,
        "updated_at": "2018-05-08T16:56:27.210Z",
        "reply_count": 0,
        "reply_to_post_number": 6,
        "quote_count": 1,
        "incoming_link_count": 2,
        "reads": 27,
        "readers_count": 26,
        "score": 15.4,
        "yours": false,
        "topic_id": 365,
        "topic_slug": "detecting-cluster-availability-transitions-for-long-running-clients",
        "display_username": "Christophe Chevalier",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 53,
        "hidden": false,
        "trust_level": 2,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/detecting-cluster-availability-transitions-for-long-running-clients/365/8",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 962,
        "name": "A.J. Beamon",
        "username": "ajbeamon",
        "avatar_template": "/user_avatar/forums.foundationdb.org/ajbeamon/{size}/13_2.png",
        "created_at": "2018-05-08T17:59:06.057Z",
        "cooked": "<aside class=\"quote no-group\" data-username=\"KrzysFR\" data-post=\"7\" data-topic=\"365\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/krzysfr/48/43_2.png\" class=\"avatar\"> KrzysFR:</div>\n<blockquote>\n<p>My idea was that the client library already has to do this sort of things, and the polling here is probably happening at the socket layer with keep alive messages that are send to some coordinator or proxy node. This is probably very efficient. If I would do the same thing at the application level, I would need to probably read a key (or maybe get a read version) which will take more cpu time from the processes (and require more network roundtrips).</p>\n</blockquote>\n</aside>\n<p>To elaborate on what I said earlier, what constitutes the database being down? It can be down while all of the processes remain up and responsive, and it can be up but with the client unable to connect to some or all of it. And all of these states can be of arbitrarily short or long duration. We\u2019ve designed the client so that these all appear to the client as an extra source of latency. During a transaction sub-system recovery, for example, the database is \u201cdown\u201d, but this condition is usually fairly short-lived and probably shouldn\u2019t be regarded as down from the client perspective. This is why it\u2019s useful to have a timeout here, and if it exists it probably should be a duration specified by the client rather than us.</p>\n<aside class=\"quote no-group\" data-username=\"KrzysFR\" data-post=\"7\" data-topic=\"365\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/krzysfr/48/43_2.png\" class=\"avatar\"> KrzysFR:</div>\n<blockquote>\n<p>I would need shorter timeouts, but then it will be too trigger happy, and now I\u2019m faced with a magic number that is always too long and too short at the same time.</p>\n</blockquote>\n</aside>\n<p>Right, that\u2019s what I was getting at with suggesting having distinct timeouts for the two cases, though I\u2019m not fully convinced yet that this is a useful distinction. Perhaps what may be useful is the ability to specify separate timeouts for transactions and operations. Transaction timeouts last the entire duration of the transaction, including retries, so they do need to be made long enough to account for the possibility of retries. However, it may be the case that you want to fail early if the database doesn\u2019t respond to any given operation in some smaller duration. I guess you could argue that the database is more likely to eventually respond to a slow running request within your normal timeout if it\u2019s \u201cup\u201d by some measure, but that seems hard to really quantify. Many cases where the database is \u201cdown\u201d are probably short-lived too.</p>",
        "post_number": 9,
        "post_type": 1,
        "posts_count": 9,
        "updated_at": "2018-05-08T17:59:06.057Z",
        "reply_count": 0,
        "reply_to_post_number": 7,
        "quote_count": 1,
        "incoming_link_count": 1,
        "reads": 28,
        "readers_count": 27,
        "score": 10.6,
        "yours": false,
        "topic_id": 365,
        "topic_slug": "detecting-cluster-availability-transitions-for-long-running-clients",
        "display_username": "A.J. Beamon",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": true,
        "staff": true,
        "user_id": 12,
        "hidden": false,
        "trust_level": 4,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/detecting-cluster-availability-transitions-for-long-running-clients/365/9",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      }
    ],
    "stream": [
      889,
      919,
      921,
      924,
      943,
      954,
      956,
      957,
      962
    ]
  },
  "timeline_lookup": [
    [
      1,
      2725
    ],
    [
      2,
      2724
    ],
    [
      6,
      2723
    ]
  ],
  "suggested_topics": [],
  "tags": [],
  "tags_descriptions": {},
  "fancy_title": "Detecting cluster availability transitions for long running clients",
  "id": 365,
  "title": "Detecting cluster availability transitions for long running clients",
  "posts_count": 9,
  "created_at": "2018-05-07T08:18:42.873Z",
  "views": 1318,
  "reply_count": 7,
  "like_count": 2,
  "last_posted_at": "2018-05-08T17:59:06.057Z",
  "visible": true,
  "closed": false,
  "archived": false,
  "has_summary": false,
  "archetype": "regular",
  "slug": "detecting-cluster-availability-transitions-for-long-running-clients",
  "category_id": 7,
  "word_count": 3585,
  "deleted_at": null,
  "user_id": 53,
  "featured_link": null,
  "pinned_globally": false,
  "pinned_at": null,
  "pinned_until": null,
  "image_url": null,
  "slow_mode_seconds": 0,
  "draft": null,
  "draft_key": "topic_365",
  "draft_sequence": null,
  "unpinned": null,
  "pinned": false,
  "current_post_number": 1,
  "highest_post_number": 9,
  "deleted_by": null,
  "actions_summary": [
    {
      "id": 4,
      "count": 0,
      "hidden": false,
      "can_act": false
    },
    {
      "id": 8,
      "count": 0,
      "hidden": false,
      "can_act": false
    },
    {
      "id": 10,
      "count": 0,
      "hidden": false,
      "can_act": false
    },
    {
      "id": 7,
      "count": 0,
      "hidden": false,
      "can_act": false
    }
  ],
  "chunk_size": 20,
  "bookmarked": false,
  "topic_timer": null,
  "message_bus_last_id": 0,
  "participant_count": 3,
  "show_read_indicator": false,
  "thumbnails": null,
  "slow_mode_enabled_until": null,
  "tags_disable_ads": false,
  "related_topics": [
    {
      "fancy_title": "Fdb-zk: rough cut of Zookeeper API layer",
      "id": 1278,
      "title": "Fdb-zk: rough cut of Zookeeper API layer",
      "slug": "fdb-zk-rough-cut-of-zookeeper-api-layer",
      "posts_count": 7,
      "reply_count": 3,
      "highest_post_number": 7,
      "image_url": null,
      "created_at": "2019-04-03T02:54:03.579Z",
      "last_posted_at": "2019-04-09T04:13:12.883Z",
      "bumped": true,
      "bumped_at": "2019-04-09T04:13:12.883Z",
      "archetype": "regular",
      "unseen": false,
      "pinned": false,
      "unpinned": null,
      "visible": true,
      "closed": false,
      "archived": false,
      "bookmarked": null,
      "liked": null,
      "tags": [],
      "tags_descriptions": {},
      "like_count": 6,
      "views": 5102,
      "category_id": 7,
      "featured_link": null,
      "has_accepted_answer": false,
      "posters": [
        {
          "extras": "latest",
          "description": "Original Poster, Most Recent Poster",
          "user": {
            "id": 113,
            "username": "pH14",
            "name": "",
            "avatar_template": "/user_avatar/forums.foundationdb.org/ph14/{size}/92_2.png",
            "trust_level": 1
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 81,
            "username": "ryanworl",
            "name": "Ryan Worl",
            "avatar_template": "/user_avatar/forums.foundationdb.org/ryanworl/{size}/440_2.png",
            "trust_level": 3
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 13,
            "username": "alexmiller",
            "name": "Alex Miller",
            "avatar_template": "/user_avatar/forums.foundationdb.org/alexmiller/{size}/326_2.png",
            "trust_level": 4
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 22,
            "username": "dave",
            "name": "David Scherer",
            "avatar_template": "/user_avatar/forums.foundationdb.org/dave/{size}/89_2.png",
            "trust_level": 1
          }
        }
      ]
    },
    {
      "fancy_title": "Troubles scaling up the cluster",
      "id": 751,
      "title": "Troubles scaling up the cluster",
      "slug": "troubles-scaling-up-the-cluster",
      "posts_count": 32,
      "reply_count": 26,
      "highest_post_number": 32,
      "image_url": null,
      "created_at": "2018-10-08T03:24:54.004Z",
      "last_posted_at": "2018-11-01T16:26:01.527Z",
      "bumped": true,
      "bumped_at": "2018-11-01T16:26:01.527Z",
      "archetype": "regular",
      "unseen": false,
      "pinned": false,
      "unpinned": null,
      "visible": true,
      "closed": false,
      "archived": false,
      "bookmarked": null,
      "liked": null,
      "tags": [],
      "tags_descriptions": {},
      "like_count": 0,
      "views": 3747,
      "category_id": 7,
      "featured_link": null,
      "has_accepted_answer": false,
      "posters": [
        {
          "extras": "latest",
          "description": "Original Poster, Most Recent Poster",
          "user": {
            "id": 311,
            "username": "ThomasJ",
            "name": "Thomas Johson",
            "avatar_template": "https://avatars.discourse-cdn.com/v4/letter/t/6f9a4e/{size}.png",
            "trust_level": 2
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 15,
            "username": "markus.pilman",
            "name": "Markus Pilman",
            "avatar_template": "/user_avatar/forums.foundationdb.org/markus.pilman/{size}/379_2.png",
            "admin": true,
            "trust_level": 4
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 255,
            "username": "aqua",
            "name": "Matt Lohier",
            "avatar_template": "https://avatars.discourse-cdn.com/v4/letter/a/b9bd4f/{size}.png",
            "trust_level": 1
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 13,
            "username": "alexmiller",
            "name": "Alex Miller",
            "avatar_template": "/user_avatar/forums.foundationdb.org/alexmiller/{size}/326_2.png",
            "trust_level": 4
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 12,
            "username": "ajbeamon",
            "name": "A.J. Beamon",
            "avatar_template": "/user_avatar/forums.foundationdb.org/ajbeamon/{size}/13_2.png",
            "admin": true,
            "trust_level": 4
          }
        }
      ]
    },
    {
      "fancy_title": "Technical overview of the database",
      "id": 135,
      "title": "Technical overview of the database",
      "slug": "technical-overview-of-the-database",
      "posts_count": 27,
      "reply_count": 15,
      "highest_post_number": 27,
      "image_url": null,
      "created_at": "2018-04-20T15:30:31.788Z",
      "last_posted_at": "2019-01-11T23:25:47.462Z",
      "bumped": true,
      "bumped_at": "2019-01-11T23:25:47.462Z",
      "archetype": "regular",
      "unseen": false,
      "pinned": false,
      "unpinned": null,
      "visible": true,
      "closed": false,
      "archived": false,
      "bookmarked": null,
      "liked": null,
      "tags": [],
      "tags_descriptions": {},
      "like_count": 64,
      "views": 12958,
      "category_id": 7,
      "featured_link": null,
      "has_accepted_answer": false,
      "posters": [
        {
          "extras": null,
          "description": "Original Poster",
          "user": {
            "id": 96,
            "username": "idiot",
            "name": "",
            "avatar_template": "https://avatars.discourse-cdn.com/v4/letter/i/f04885/{size}.png",
            "trust_level": 1
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 22,
            "username": "dave",
            "name": "David Scherer",
            "avatar_template": "/user_avatar/forums.foundationdb.org/dave/{size}/89_2.png",
            "trust_level": 1
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 13,
            "username": "alexmiller",
            "name": "Alex Miller",
            "avatar_template": "/user_avatar/forums.foundationdb.org/alexmiller/{size}/326_2.png",
            "trust_level": 4
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 443,
            "username": "junius",
            "name": "junius",
            "avatar_template": "https://avatars.discourse-cdn.com/v4/letter/j/f08c70/{size}.png",
            "trust_level": 1
          }
        },
        {
          "extras": "latest",
          "description": "Most Recent Poster",
          "user": {
            "id": 54,
            "username": "Evan",
            "name": "Evan Tschannen",
            "avatar_template": "/user_avatar/forums.foundationdb.org/evan/{size}/104_2.png",
            "moderator": true,
            "trust_level": 1
          }
        }
      ]
    },
    {
      "fancy_title": "Changefeeds (watching and getting updates on ranges of keys)",
      "id": 511,
      "title": "Changefeeds (watching and getting updates on ranges of keys)",
      "slug": "changefeeds-watching-and-getting-updates-on-ranges-of-keys",
      "posts_count": 9,
      "reply_count": 7,
      "highest_post_number": 9,
      "image_url": null,
      "created_at": "2018-06-16T12:26:34.710Z",
      "last_posted_at": "2018-07-06T14:46:54.646Z",
      "bumped": true,
      "bumped_at": "2018-07-06T14:46:54.646Z",
      "archetype": "regular",
      "unseen": false,
      "pinned": false,
      "unpinned": null,
      "visible": true,
      "closed": false,
      "archived": false,
      "bookmarked": null,
      "liked": null,
      "tags": [],
      "tags_descriptions": {},
      "like_count": 2,
      "views": 4221,
      "category_id": 7,
      "featured_link": null,
      "has_accepted_answer": false,
      "posters": [
        {
          "extras": "latest",
          "description": "Original Poster, Most Recent Poster",
          "user": {
            "id": 307,
            "username": "jwr",
            "name": "Jan Rychter",
            "avatar_template": "/user_avatar/forums.foundationdb.org/jwr/{size}/302_2.png",
            "trust_level": 2
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 8,
            "username": "alloc",
            "name": "Alec Grieser",
            "avatar_template": "/user_avatar/forums.foundationdb.org/alloc/{size}/9_2.png",
            "trust_level": 4
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 12,
            "username": "ajbeamon",
            "name": "A.J. Beamon",
            "avatar_template": "/user_avatar/forums.foundationdb.org/ajbeamon/{size}/13_2.png",
            "admin": true,
            "trust_level": 4
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 22,
            "username": "dave",
            "name": "David Scherer",
            "avatar_template": "/user_avatar/forums.foundationdb.org/dave/{size}/89_2.png",
            "trust_level": 1
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 13,
            "username": "alexmiller",
            "name": "Alex Miller",
            "avatar_template": "/user_avatar/forums.foundationdb.org/alexmiller/{size}/326_2.png",
            "trust_level": 4
          }
        }
      ]
    },
    {
      "fancy_title": "Performance characteristics of using Watches for Distributed Task Scheduling",
      "id": 471,
      "title": "Performance characteristics of using Watches for Distributed Task Scheduling",
      "slug": "performance-characteristics-of-using-watches-for-distributed-task-scheduling",
      "posts_count": 28,
      "reply_count": 13,
      "highest_post_number": 28,
      "image_url": "https://global.discourse-cdn.com/foundationdb/original/1X/0819f4ad7c04fe7d847b2f33824849dc70ee6a0c.png",
      "created_at": "2018-05-24T13:42:28.764Z",
      "last_posted_at": "2018-08-16T03:57:50.737Z",
      "bumped": true,
      "bumped_at": "2018-08-16T03:57:50.737Z",
      "archetype": "regular",
      "unseen": false,
      "pinned": false,
      "unpinned": null,
      "visible": true,
      "closed": false,
      "archived": false,
      "bookmarked": null,
      "liked": null,
      "tags": [
        "performance"
      ],
      "tags_descriptions": {},
      "like_count": 15,
      "views": 5180,
      "category_id": 9,
      "featured_link": null,
      "has_accepted_answer": false,
      "posters": [
        {
          "extras": null,
          "description": "Original Poster",
          "user": {
            "id": 53,
            "username": "KrzysFR",
            "name": "Christophe Chevalier",
            "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
            "trust_level": 2
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 13,
            "username": "alexmiller",
            "name": "Alex Miller",
            "avatar_template": "/user_avatar/forums.foundationdb.org/alexmiller/{size}/326_2.png",
            "trust_level": 4
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 118,
            "username": "abdullin",
            "name": "Rinat Abdullin",
            "avatar_template": "/user_avatar/forums.foundationdb.org/abdullin/{size}/83_2.png",
            "trust_level": 2
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 12,
            "username": "ajbeamon",
            "name": "A.J. Beamon",
            "avatar_template": "/user_avatar/forums.foundationdb.org/ajbeamon/{size}/13_2.png",
            "admin": true,
            "trust_level": 4
          }
        },
        {
          "extras": "latest",
          "description": "Most Recent Poster",
          "user": {
            "id": 68,
            "username": "daverosenthal",
            "name": "Dave Rosenthal",
            "avatar_template": "/user_avatar/forums.foundationdb.org/daverosenthal/{size}/51_2.png",
            "trust_level": 2
          }
        }
      ]
    }
  ],
  "summarizable": false,
  "can_vote": false,
  "vote_count": 0,
  "user_voted": false,
  "discourse_zendesk_plugin_zendesk_id": null,
  "discourse_zendesk_plugin_zendesk_url": "https://your-url.zendesk.com/agent/tickets/",
  "details": {
    "can_edit": false,
    "notification_level": 1,
    "participants": [
      {
        "id": 53,
        "username": "KrzysFR",
        "name": "Christophe Chevalier",
        "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
        "post_count": 5,
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_color": null,
        "flair_bg_color": null,
        "flair_group_id": null,
        "trust_level": 2
      },
      {
        "id": 12,
        "username": "ajbeamon",
        "name": "A.J. Beamon",
        "avatar_template": "/user_avatar/forums.foundationdb.org/ajbeamon/{size}/13_2.png",
        "post_count": 3,
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_color": null,
        "flair_bg_color": null,
        "flair_group_id": null,
        "admin": true,
        "trust_level": 4
      },
      {
        "id": 22,
        "username": "dave",
        "name": "David Scherer",
        "avatar_template": "/user_avatar/forums.foundationdb.org/dave/{size}/89_2.png",
        "post_count": 1,
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_color": null,
        "flair_bg_color": null,
        "flair_group_id": null,
        "trust_level": 1
      }
    ],
    "created_by": {
      "id": 53,
      "username": "KrzysFR",
      "name": "Christophe Chevalier",
      "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png"
    },
    "last_poster": {
      "id": 12,
      "username": "ajbeamon",
      "name": "A.J. Beamon",
      "avatar_template": "/user_avatar/forums.foundationdb.org/ajbeamon/{size}/13_2.png"
    }
  },
  "bookmarks": []
}