{
  "post_stream": {
    "posts": [
      {
        "id": 527,
        "name": "Christophe Chevalier",
        "username": "KrzysFR",
        "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
        "created_at": "2018-04-24T19:05:12.006Z",
        "cooked": "<p>I\u2019m currently adding support to VersionStamps in the .NET Binding.</p>\n<p>I\u2019m a bit confused by some discrepencies between the documentation, code implementation, and behaviour I\u2019m seeing. Also, I was not able to find a lot of documentation on this subject, and no concrete example.</p>\n<h3><a name=\"h-10-bytes-or-12-bytes-1\" class=\"anchor\" href=\"#h-10-bytes-or-12-bytes-1\"></a>10 bytes or 12 bytes?</h3>\n<p><strong>UPDATED</strong> from answers below.</p>\n<p>There are two <em>flavors</em> of Versionstamps: 80-bits and 96-bits long. The former is what the database understand, and the later is a client-side convention.</p>\n<ul>\n<li>The <strong>80-bits versionstamps</strong> are 10 bytes longs, and are composed of 8 bytes (Transaction Version) followed by 2 bytes (Transaction Batch Order). They are ordered and guaranteed to be unique per transaction. They are handled by the <code>FDB_MUTATION_TYPE_SET_VERSIONSTAMPED_KEY</code> and <code>FDB_MUTATION_TYPE_SET_VERSIONSTAMPED_VALUE</code>.</li>\n<li>The <strong>96-bits versionstamps</strong> are actually an 80-bit versionstamp followed by 2 extra bytes called <em>User Version</em>, so 12 bytes in total. These two bytes can be used if a transaction wants to insert more than one key. These two bytes are not <em>seen</em> by the database, and are just a convention at the binding level.</li>\n</ul>\n<p>Both Python and Java bindings seem to have take the route of only exposing 96-bits versionstamps at the API level, and use a default User Version of 0. So these versionstamps will always be 12 bytes. The shorter 10-bytes ones are not exposed.</p>\n<p>When the application wants to create a key using a versionstamp, it does not know the actual value yet, so the pattern is to have a <em>placehold</em> stamp, which then gets overwritten when setting a versionstamped key or value at commit time. These stamps are called <em>incomplete</em> stamps in some bindings.</p>\n<p>The binding tracks the offset in the binary key or value where this placeholder stamp is located, and pass this info to the database, who then replace the bytes with the actual stamp. After the transaction has committed, the application can guery the <em>actual</em> stamp used via <code>fdb_transaction_get_versionstamp</code>.</p>\n<p>So for example, if your layer uses keys like <code>('foo', &lt;stamp&gt;)</code>, using the Tuple Layer, the serialized binary key would look something like this:</p>\n<pre><code class=\"lang-auto\">('foo', &lt;placeholder_stamp&gt;) =&gt; &lt; 02 'foo' 00 33 xx xx xx xx xx xx xx xx xx xx 00 00 &gt;\n</code></pre>\n<p><em>note: currently, bindings will use xx = FF as placeholders but this could be anything</em></p>\n<p>The prefix <code>02 'foo' 00</code> corresponds to the encoding of the <code>'foo'</code> string, the byte <code>33</code> is the type header for 96-bits version stamps in the Tuple Encoding and is not part of the stamp. The 10 \u2018xx\u2019 are placeholders for where the actual stamp will be placed, and the last <code>00 00</code> are the user version (0 by default).</p>\n<p>When calling the <code>SetVersionstampKey</code> method, you need to pass an additional value which is the offset in the key <em>where</em> the stamp is located. This is done by adding 2 extra bytes at the end, containing the offset in little-endian. These 2 bytes are not actually <em>part</em> of the key, and will be removed by the <code>SetVersionstampedKey</code> method.</p>\n<p>Since the location of the stamp in our example above is at offset 6, the actual byte array passed to the <code>SetVersionstampedKey</code> method will be:</p>\n<pre><code class=\"lang-auto\">tr.SetVersionstampedKey( &lt; 02 'foo' 00 33 xx xx xx xx xx xx xx xx xx xx 00 00 06 00&gt;, 'hello world')\n</code></pre>\n<p>At commit time, the last two bytes are removed, and the 10 bytes are the specified offset are filled by the database. If the transaction commits at version <code>0x0123456789ABCDEF</code> with batch order <code>0x1234</code>, the key will become:</p>\n<pre><code class=\"lang-auto\">&lt; 02 'foo' 00 33 01 23 45 67 89 AB CD EF  12 34 00 00&gt; = 'hello world'\n</code></pre>\n<p>In practice, the batch order will usually be 0 or a low number (depends on the number of concurrent transactions).</p>\n<p>The first 10 bytes are controlled by the database, and the last two bytes (\u201800 00\u2019) are controlled by the user,</p>\n<p>Original question:</p>\n<aside class=\"quote no-group\">\n<blockquote>\n<p>The first is that a VersionStamp seems to be 10 or 12 bytes depending on where I look.</p>\n<ul>\n<li>The fdb.options states that <code>A versionstamp is a 10 byte, unique, monotonically (but not sequentially) increasing value for each committed transaction. The first 8 bytes are the committed version of the database. The last 2 bytes are monotonic in the serialization order for transactions.</code></li>\n<li>The Java binding does use 12 bytes total, with the first 10 being the transaction number, and the last 2 the user version, and mention the Transaction Number as explicitely being 10 bytes.</li>\n<li>The Python binding a similar thing (but is devoid of comments)</li>\n<li>The database seems to overwrite 10 bytes in my keys.</li>\n</ul>\n<p>My initial tests with a 8 bytes transaction and 2 bytes user version showed the last 2 bytes systematically overwritten with 00 00 in a way that was non-obvious: I\u2019m passing a temp key with 8 x 0xFF followed by 2 user version bytes <code>FF FF FF FF FF FF FF FF 12 34</code> and when I read back the key, I see something like <code>00 00 XX XX XX XX XX XX 00 00</code>.</p>\n<p>My initial thought that was my user version 0x1234 was overwritten with zeroes. BUT looking at the doc, and if the Transaction number is indeed 10 bytes, AND by some random chance the last two bytes of a Transaction Version are always 0, it would mean that VersionStamps are indeed 10 bytes + 2 bytes (and not 8 + 2) and that the \u201cuser version\u201d part is strictly a client-side convention, and that the VERSIONSTAMP_KEY mutation only care about the first 10 bytes (the next 2 bytes are ignored).</p>\n<p>So which is it? 12 bytes (10 + 2) or 10 bytes (8 + 2) ? Are the last 2 bytes of the transaction always 0?</p>\n<p>It looks like both JAVA and Python bindings have opted to only expose the 96 bits Versionstamps, while the core of fdb only knows about the 80 bits versionstamps\u2026</p>\n</blockquote>\n</aside>\n<h3><a name=\"custom-serialization-required-2\" class=\"anchor\" href=\"#custom-serialization-required-2\"></a>Custom Serialization Required</h3>\n<p>The way Java and Python deal with Versionstamps and tuples is a little bit \u2026 weird. I\u2019m not a big fan of having to need a custom method to build tuples that contain a versionstamp (due to the need to get the byte offset where it starts). This does not seem to play well with other serialization mechanics (like for ex combined with subspace prefixes, or other custom encodings).</p>\n<p>I was wondering if another approach would be better: using a specifc byte pattern, that is used to mark the location of a stamp (client side), and when such a byte array is passed to the VersionStampKey mutation, it would look for this pattern, and obtain the position that way. =&gt; no need for special code paths, any binary encoding scheme can simply output this pattern anywhere it wants, and it will be recognize at the last step.</p>\n<p>Obvious problem is what if this pattern is used by random chance by the key itself? It cannot be something trivial like all zeros, or all FF. Maybe <code>$VERSTAMP!$</code> or something like that?</p>\n<p>There is precendents with - for example - the multipart content encoding (<a href=\"https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">RFC1341(MIME) : 7 The Multipart content type</a>) which explicitely define what is the expected chunk separator. Most implementations may choose a constant (or random) separator, and check if it is not contained in the message itself. If it is, choose another marker.</p>\n<p>We could maybe choose to have a default token to mark the spot where a VersionStamp is, but have a mechanism (somewhere on the transaction? or as an extra paramter to the VersionStampKey helper method) to specify what was the exact token used.</p>\n<pre data-code-wrap=\"csharp\"><code class=\"lang-csharp\">// use default token\nvar key = AcmeLib.SerializeKey((\"foo\", 123, VersionStamp.Incomplete(42), 456)); // uses default token\n// -&gt; &lt;'foo',123,$VERSTAMP!$42,456&gt;\ntr.VersionStampKey(key, ....);\n\n// risk of collision\nvar key = AcmeLib.SerializeKey((\"foo\", 123, \"Oh no, I have a $VERSTAMP!$ inlined\", VersionStamp.Incomplete(42), 456), token: \"ABCDEFGHIJ\");\n// -&gt; &lt;'foo',123,'Oh no, I have a $VERSTAMP!$ inlined',ABCDEFGHIJ42,456&gt;\ntr.VersionStampKey(key, ..., token: \"ABCDEFGHIJ\");\n</code></pre>\n<p>We could even decide to generate a random token per new transaction, and ensure that it does not happen twice in the same key. If it does, then the transaction would fail, retry (with a NEW random token), and the probability that the next token would be <em>also</em> contained in another key of the same transaction would be very low.</p>\n<pre data-code-wrap=\"csharp\"><code class=\"lang-csharp\">db.Run((tr) =&gt;\n{\n    var token = tr.GetStampToken(); // -&gt; \"Aoew!4='\u00a3K\"\n    var key = AcmeLib.Serialize((\"foo\", 123, VersionStamp.Incomplete(123), 456), token);\n    // -&gt; &lt; 'foo',123,Aoew!4='\u00a3K42,456 &gt;\n    tr.VersionStampKey(key, ....);\n});\n</code></pre>\n<h3><a name=\"fdb_transaction_get_versionstamp-3\" class=\"anchor\" href=\"#fdb_transaction_get_versionstamp-3\"></a>fdb_transaction_get_versionstamp</h3>\n<p><strong>UPDATED</strong></p>\n<p>This method can be used to obtain the actual value that the database will insert into the key (or value) instead of the temporary placeholder. This value will be an 80-bit value that is the same for the whole transaction. If the transaction needed multiple ids, the way is to use an 96-bit timespan, with the last 16 bits being a user-provided integer.</p>\n<p>This method must be called BEFORE the call to <code>fdb_transaction_commit</code> and the Future will be resolved AFTER the transaction commits successfully (or fail).</p>\n<p>An exemple of Java code:</p>\n<aside class=\"quote no-group\" data-username=\"alloc\" data-post=\"5\" data-topic=\"250\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/alloc/48/9_2.png\" class=\"avatar\"> alloc:</div>\n<blockquote>\n<pre data-code-wrap=\"java\"><code class=\"lang-java\">CompletableFuture&lt;byte[]&gt; vsFuture = tr.getVersionstamp();\ntr.commit().join();  // blocking call to wait on commit\nbyte[] versionstamp = vsFuture.join(); // non-blocking call to get versionstamp\n</code></pre>\n</blockquote>\n</aside>\n<p>This may have some impact on code that use async operations (.NET, Typescript with async/await, Java with CompletableFutures, etc\u2026) especially when combined with retry loops (where the code does not manage the transaction itself, and in particular is not the one who invoke the commit method).</p>\n<p>Example of patterns that will fails:</p>\n<aside class=\"quote no-group\" data-username=\"spullara\" data-post=\"10\" data-topic=\"250\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/spullara/48/125_2.png\" class=\"avatar\"> spullara:</div>\n<blockquote>\n<p>Deadlocks, for good reason:</p>\n<pre data-code-wrap=\"java\"><code class=\"lang-java\">    byte[] versionstamp = open.runAsync(tx -&gt; {\n      byte[] key = ds.get(\"test\").packWithVersionstamp(Tuple.from(Versionstamp.incomplete()));\n      tx.mutate(SET_VERSIONSTAMPED_KEY, key, \"test\".getBytes());\n      return tx.getVersionstamp();\n    }).get();\n</code></pre>\n<p>Cannot access closed object:</p>\n<pre data-code-wrap=\"java\"><code class=\"lang-java\">    byte[] versionstamp = open.runAsync(tx -&gt; {\n      byte[] key = ds.get(\"test\").packWithVersionstamp(Tuple.from(Versionstamp.incomplete()));\n      tx.mutate(SET_VERSIONSTAMPED_KEY, key, \"test\".getBytes());\n      return CompletableFuture.completedFuture(tx);\n    }).get().getVersionstamp().get();\n</code></pre>\n<p>OR</p>\n<pre data-code-wrap=\"java\"><code class=\"lang-java\">    byte[] versionstamp = open.runAsync(tx -&gt; {\n      byte[] key = ds.get(\"test\").packWithVersionstamp(Tuple.from(Versionstamp.incomplete()));\n      tx.mutate(SET_VERSIONSTAMPED_KEY, key, \"test\".getBytes());\n      return CompletableFuture.completedFuture(tx);\n    }).thenApply(Transaction::getVersionstamp).get().get();\n</code></pre>\n</blockquote>\n</aside>\n<p>Some possible solutions for Java:</p>\n<aside class=\"quote no-group quote-modified\" data-username=\"spullara\" data-post=\"10\" data-topic=\"250\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/spullara/48/125_2.png\" class=\"avatar\"> spullara:</div>\n<blockquote>\n<p>Works:</p>\n<pre data-code-wrap=\"java\"><code class=\"lang-java\">    byte[] versionstamp = open.run(tx -&gt; {\n      byte[] key = ds.get(\"test\").packWithVersionstamp(Tuple.from(Versionstamp.incomplete()));\n      tx.mutate(SET_VERSIONSTAMPED_KEY, key, \"test\".getBytes());\n      return tx.getVersionstamp();\n    }).get();\n</code></pre>\n<p>Awkward but works:</p>\n<pre data-code-wrap=\"java\"><code class=\"lang-java\">    byte[] versionstamp = open.runAsync(tx -&gt; {\n      byte[] key = ds.get(\"test\").packWithVersionstamp(Tuple.from(Versionstamp.incomplete()));\n      tx.mutate(SET_VERSIONSTAMPED_KEY, key, \"test\".getBytes());\n      return CompletableFuture.completedFuture(tx.getVersionstamp());\n    }).get().get();\n</code></pre>\n</blockquote>\n</aside>\n<p>Original question:</p>\n<aside class=\"quote no-group\">\n<blockquote>\n<p>This is one maybe an error on my end, but when I call <code>fdb_transaction_get_versionstamp</code> I get the error 2017 with message <code>Operation issued while a commit was outstanding</code>, even though the commit was successfull: the data is stored in the database, and I can even get the commit version before calling get_versionstamp.</p>\n<p>It returns an already completed Future, with error 2017 (UsedDuringCommit).</p>\n<p>Any idea?</p>\n</blockquote>\n</aside>",
        "post_number": 1,
        "post_type": 1,
        "posts_count": 25,
        "updated_at": "2018-04-26T16:34:43.045Z",
        "reply_count": 1,
        "reply_to_post_number": null,
        "quote_count": 2,
        "incoming_link_count": 817,
        "reads": 145,
        "readers_count": 144,
        "score": 4140.0,
        "yours": false,
        "topic_id": 250,
        "topic_slug": "implementing-versionstamps-in-bindings",
        "display_username": "Christophe Chevalier",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 6,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "link_counts": [
          {
            "url": "https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html",
            "internal": false,
            "reflection": false,
            "title": "RFC1341(MIME) : 7 The Multipart content type",
            "clicks": 1
          },
          {
            "url": "https://forums.foundationdb.org/t/foundationdb-net-standard/193/12",
            "internal": true,
            "reflection": true,
            "title": "FoundationDB .NET Standard",
            "clicks": 0
          },
          {
            "url": "https://forums.foundationdb.org/t/use-case-of-versionstamp-and-behavior-of-pack-with-versionstamp/869/2",
            "internal": true,
            "reflection": true,
            "title": "Use case of versionstamp and behavior of pack_with_versionstamp",
            "clicks": 0
          }
        ],
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [
          {
            "id": 2,
            "count": 1
          }
        ],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 53,
        "hidden": false,
        "trust_level": 2,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/implementing-versionstamps-in-bindings/250/1",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null,
        "can_vote": false
      },
      {
        "id": 528,
        "name": "David Scherer",
        "username": "dave",
        "avatar_template": "/user_avatar/forums.foundationdb.org/dave/{size}/89_2.png",
        "created_at": "2018-04-24T19:39:03.832Z",
        "cooked": "<p>As far as the FDB core is concerned, versionstamps are 10 bytes: 8 bytes of version + 2 bytes transaction number within version.</p>\n<p>As far as the tuple format is concerned, versionstamps are 12 bytes: 8 bytes of version + 2 bytes transaction number within version + 2 bytes operation counter within transaction</p>\n<p>The latter format is obviously designed so that you can fill it in successfully with the help of the built in FDB operations.  But FDB itself doesn\u2019t know anything about the format of the last 2 bytes.</p>\n<p>Does that help?</p>",
        "post_number": 2,
        "post_type": 1,
        "posts_count": 25,
        "updated_at": "2018-04-24T19:39:03.832Z",
        "reply_count": 1,
        "reply_to_post_number": null,
        "quote_count": 0,
        "incoming_link_count": 3,
        "reads": 107,
        "readers_count": 106,
        "score": 41.4,
        "yours": false,
        "topic_id": 250,
        "topic_slug": "implementing-versionstamps-in-bindings",
        "display_username": "David Scherer",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 22,
        "hidden": false,
        "trust_level": 1,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/implementing-versionstamps-in-bindings/250/2",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 531,
        "name": "Christophe Chevalier",
        "username": "KrzysFR",
        "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
        "created_at": "2018-04-24T20:02:08.556Z",
        "cooked": "<p>Yes. So what is the \u201coperation counter within a transaction\u201d? in all my tests, the 2 bytes at ofset 8 and 9 are always 0. What are the conditions required to see a non-zero value there?</p>\n<p>At first glance it seems redundant with the user version (extra 2 bytes).</p>",
        "post_number": 3,
        "post_type": 1,
        "posts_count": 25,
        "updated_at": "2018-04-24T20:02:51.090Z",
        "reply_count": 2,
        "reply_to_post_number": 2,
        "quote_count": 0,
        "incoming_link_count": 1,
        "reads": 105,
        "readers_count": 104,
        "score": 36.0,
        "yours": false,
        "topic_id": 250,
        "topic_slug": "implementing-versionstamps-in-bindings",
        "display_username": "Christophe Chevalier",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "reply_to_user": {
          "id": 22,
          "username": "dave",
          "name": "David Scherer",
          "avatar_template": "/user_avatar/forums.foundationdb.org/dave/{size}/89_2.png"
        },
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 53,
        "hidden": false,
        "trust_level": 2,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/implementing-versionstamps-in-bindings/250/3",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 541,
        "name": "David Scherer",
        "username": "dave",
        "avatar_template": "/user_avatar/forums.foundationdb.org/dave/{size}/89_2.png",
        "created_at": "2018-04-24T23:42:41.998Z",
        "cooked": "<p>It <em>is</em> the same as the user version.</p>\n<p>VVVVVVVVTTUU</p>\n<p>8 bytes version (filled by FDB)<br>\n2 bytes transaction# within version (filled by FDB)<br>\n2 bytes \u201cuser version\u201d  (<em>you</em> should usually set this to 0 for the first versionstamped item you insert during a transaction, 1 for the second, etc)</p>\n<p>The reason that the last 2 bytes can\u2019t be filled in automatically is because you very well may want to insert logically-the-same versionstamped item in more than one <em>index</em>, in which case it\u2019s critical that it get the exact same (12-byte) versionstamp in each place.  But the API can\u2019t distinguish that from inserting two different versionstamped items, in which case you probably want to give them different versionstamps to preserve their order.</p>",
        "post_number": 4,
        "post_type": 1,
        "posts_count": 25,
        "updated_at": "2018-04-24T23:42:41.998Z",
        "reply_count": 1,
        "reply_to_post_number": 3,
        "quote_count": 0,
        "incoming_link_count": 3,
        "reads": 111,
        "readers_count": 110,
        "score": 57.2,
        "yours": false,
        "topic_id": 250,
        "topic_slug": "implementing-versionstamps-in-bindings",
        "display_username": "David Scherer",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "reply_to_user": {
          "id": 53,
          "username": "KrzysFR",
          "name": "Christophe Chevalier",
          "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png"
        },
        "bookmarked": false,
        "actions_summary": [
          {
            "id": 2,
            "count": 1
          }
        ],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 22,
        "hidden": false,
        "trust_level": 1,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/implementing-versionstamps-in-bindings/250/4",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 552,
        "name": "Alec Grieser",
        "username": "alloc",
        "avatar_template": "/user_avatar/forums.foundationdb.org/alloc/{size}/9_2.png",
        "created_at": "2018-04-25T04:57:06.756Z",
        "cooked": "<aside class=\"quote no-group\" data-username=\"KrzysFR\" data-post=\"1\" data-topic=\"250\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/krzysfr/48/43_2.png\" class=\"avatar\"> KrzysFR:</div>\n<blockquote>\n<p>So which is it? 12 bytes (10 + 2) or 10 bytes (8 + 2) ? Are the last 2 bytes of the transaction always 0?</p>\n</blockquote>\n</aside>\n<p>Hm, yeah, this might have been an instance where brevity was chosen instead of clarity. Maybe a 12 byte \u201cversionstamp\u201d should have been an ExtendedVersionstamp or something to indicate it is different from a 10 byte versionstamp? \u00af\\_(\u30c4)_/\u00af</p>\n<aside class=\"quote no-group\" data-username=\"KrzysFR\" data-post=\"1\" data-topic=\"250\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/krzysfr/48/43_2.png\" class=\"avatar\"> KrzysFR:</div>\n<blockquote>\n<p>Obvious problem is what if this pattern is used by random chance by the key itself? It cannot be something trivial like all zeros, or all FF. Maybe $VERSTAMP!$ or something like that?</p>\n</blockquote>\n</aside>\n<p>This can be improved somewhat by the fact that it will be the magic string preceded by the versionstamp type code, which might make it less likely to collide (or, well, maybe not). We ultimately decided that a magic string was more error prone than the extra methods were bad ergonomically, so we went with what\u2019s in the codebase now. To handle subspaces, we added methods to pack a tuple with a prefix so that the prefix length gets added in to the offset correctly. It doesn\u2019t quite work for suffixes, but that seems to be less common.</p>\n<aside class=\"quote no-group\" data-username=\"KrzysFR\" data-post=\"3\" data-topic=\"250\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/krzysfr/48/43_2.png\" class=\"avatar\"> KrzysFR:</div>\n<blockquote>\n<p>So what is the \u201coperation counter within a transaction\u201d?</p>\n</blockquote>\n</aside>\n<p>What are your order of operations? The get_versionstamp method is somewhat weird, but you have to call the future before it is committed, and then that future will be ready only after the commit. So something like:</p>\n<pre data-code-wrap=\"java\"><code class=\"lang-java\">CompletableFuture&lt;byte[]&gt; vsFuture = tr.getVersionstamp();\ntr.commit().join();  // blocking call to wait on commit\nbyte[] versionstamp = vsFuture.join(); // non-blocking call to get versionstamp\n</code></pre>\n<p>(But, like, in C# instead of Java.) I think you can get used_during_commit if you call <code>getVersionstamp</code> after commit rather than before.</p>\n<aside class=\"quote no-group\" data-username=\"KrzysFR\" data-post=\"3\" data-topic=\"250\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/krzysfr/48/43_2.png\" class=\"avatar\"> KrzysFR:</div>\n<blockquote>\n<p>in all my tests, the 2 bytes at ofset 8 and 9 are always 0. What are the conditions required to see a non-zero value there?</p>\n</blockquote>\n</aside>\n<p>Are you only ever running one transaction at a time? You will only see a non-zero \u201cbatch version\u201d (we call it) if there are multiple transactions being committed together at a single version, which can only happen if there are concurrent commits. The easiest way is to probably fire off multiple transactions and then wait for all of them.</p>\n<aside class=\"quote no-group\" data-username=\"dave\" data-post=\"4\" data-topic=\"250\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/dave/48/89_2.png\" class=\"avatar\"> dave:</div>\n<blockquote>\n<p>The reason that the last 2 bytes can\u2019t be filled in automatically is because you very well may want to insert logically-the-same versionstamped item in more than one index, in which case it\u2019s critical that it get the exact same (12-byte) versionstamp in each place.</p>\n</blockquote>\n</aside>\n<p>Just to expand on this a little, with versionstamps in particular, it\u2019s often the case that you will want a forward index and a reverse index, i.e., <code>(keyspace_1, key) -&gt; version</code> and <code>(keyspace_2, version) -&gt; key</code>. There are a couple of reasons for this, but the most obvious is that as you don\u2019t know what key you wrote if you only write the one with a version, then to remove that key, you have to somehow figure out what that version was. So you can either scan the keyspace_2 (slow) or look it up in the other index (fast). The other less obvious reason is that if you get a <code>commit_uknown_result</code> error, then if all you had were the index with versions in <code>keyspace_2</code>, it would be really easy to add multiple entries in <code>keyspace_2</code> in subsequent retries by mistake. Having <code>keyspace_1</code> around let\u2019s you either detect that you are in a retry loop and not write it again (essentially letting you know that your commit succeeded) or, if index maintenance is done correctly, lets you clean up <code>keyspace_1</code> and <code>keyspace_2</code> within the retry loop. But all of that depends on the versionstamp having the same user version each time for a logical record within the database.</p>",
        "post_number": 5,
        "post_type": 1,
        "posts_count": 25,
        "updated_at": "2018-04-25T04:57:06.756Z",
        "reply_count": 3,
        "reply_to_post_number": 4,
        "quote_count": 3,
        "incoming_link_count": 6,
        "reads": 109,
        "readers_count": 108,
        "score": 66.8,
        "yours": false,
        "topic_id": 250,
        "topic_slug": "implementing-versionstamps-in-bindings",
        "display_username": "Alec Grieser",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "link_counts": [
          {
            "url": "https://forums.foundationdb.org/t/unable-to-use-conflicting-keys-special-keyspace-with-go-bindings/3097",
            "internal": true,
            "reflection": true,
            "title": "Unable to use conflicting keys special keyspace with Go bindings",
            "clicks": 1
          }
        ],
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 8,
        "hidden": false,
        "trust_level": 4,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/implementing-versionstamps-in-bindings/250/5",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 560,
        "name": "Christophe Chevalier",
        "username": "KrzysFR",
        "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
        "created_at": "2018-04-25T08:11:51.248Z",
        "cooked": "<p>I have updated the original question about stamp size from these answers.</p>",
        "post_number": 6,
        "post_type": 1,
        "posts_count": 25,
        "updated_at": "2018-04-25T08:11:51.248Z",
        "reply_count": 0,
        "reply_to_post_number": 5,
        "quote_count": 0,
        "incoming_link_count": 1,
        "reads": 90,
        "readers_count": 89,
        "score": 23.0,
        "yours": false,
        "topic_id": 250,
        "topic_slug": "implementing-versionstamps-in-bindings",
        "display_username": "Christophe Chevalier",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "reply_to_user": {
          "id": 8,
          "username": "alloc",
          "name": "Alec Grieser",
          "avatar_template": "/user_avatar/forums.foundationdb.org/alloc/{size}/9_2.png"
        },
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 53,
        "hidden": false,
        "trust_level": 2,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/implementing-versionstamps-in-bindings/250/6",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 562,
        "name": "Christophe Chevalier",
        "username": "KrzysFR",
        "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
        "created_at": "2018-04-25T08:50:37.048Z",
        "cooked": "<aside class=\"quote no-group quote-modified\" data-username=\"alloc\" data-post=\"5\" data-topic=\"250\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/alloc/48/9_2.png\" class=\"avatar\"> alloc:</div>\n<blockquote>\n<p>What are your order of operations? The get_versionstamp method is somewhat weird, but you have to call the future before it is committed, and then that future will be ready only after the commit. So something like:</p>\n<p>CompletableFuture&lt;byte<span class=\"chcklst-box fa fa-square-o fa-fw\"></span>&gt; vsFuture = tr.getVersionstamp();<br>\ntr.commit().join();  // blocking call to wait on commit<br>\nbyte<span class=\"chcklst-box fa fa-square-o fa-fw\"></span> versionstamp = vsFuture.join(); // non-blocking call to get versionstamp</p>\n<p>(But, like, in C# instead of Java.) I think you can get used_during_commit if you call getVersionstamp after commit rather than before.</p>\n</blockquote>\n</aside>\n<p>Ok so this is a bit confusing. I\u2019m calling the getVersionstamp method AFTER the commit has completed, but I\u2019m getting an error <code>Operation issued while a commit was outstanding</code> which seems wrong to me: The commit was already completed, so it was not \u201c<em>while</em>\u201d and there was no \u201c<em>outstanding</em>\u201d commit? Maybe the wording of the error message is wrong?</p>\n<blockquote>\n<p>[\u2026] but you have to call the future before it is committed, and then that future will be ready only after the commit</p>\n</blockquote>\n<p>I\u2019m having some issues with this API, because it will seem a little bit weird - from a .NET coder\u2019s point of view - when dealing with tasks, AND it does not appear to compose well with retry loops and multiple layers.</p>\n<p>My test creates and commits the transaction manually, but typical application will never do that and go through one of the retry loops (the <code>db.run(...)</code> in Java):</p>\n<pre data-code-wrap=\"csharp\"><code class=\"lang-csharp\">\nTask&lt;IActionReuslt&gt; SomeControllerMethod(....)\n{\n  //... check args ...\n  await db.WriteAsync((tr) =&gt;\n  {   \n     // traditional write operations\n     tr.ClearRange(....);\n     tr.Set(..., ...);\n     // new Versionstamp API\n     tr.SetVersionstampedKey(MAKE_KEY_WITH_VERSION_STAMP(), ....);\n\n  }, HttpContext.Cancel);\n  //...\n  return View(....);\n}\n</code></pre>\n<p><em>obviously, the db code would be inside some Business Logic class, and not inlined in the controller!</em></p>\n<p>If the code wanted to obtain the actual Versionstamp, as well as some other result extracted from the database, both at the same time, it will look very ugly:</p>\n<pre data-code-wrap=\"csharp\"><code class=\"lang-csharp\">//...\nTask&lt;Versionstamp&gt; stampTask; // out of scope\nSlice result = await db.ReadWriteAsync((tr) =&gt;\n{\n     var val = await tr.Get('SOME_KEY', ....);\n\n     tr.SetVersionstampedKey(MAKE_KEY_WITH_VERSION_STAMP(), ..);\n     stampTask = tr.GetVersionstamp();\n\n     return val;\n}, cancel);\nVersionstamp stamp = await stampTask; // need an extra await here!\n//...\nvar data = DoSomethingWithIt(result, stamp);\nreturn View(new SpomeViewModel { Data = data, ... });\n</code></pre>\n<p>Having to hoist a task outside the scope and do an additional await looks <em>weird</em> in moden .NET code.</p>\n<p>The retry loop could return the Versionstamp task alongside the result like this, but again it does not look nice:</p>\n<pre data-code-wrap=\"csharp\"><code class=\"lang-csharp\">(Slice result, Task&lt;Versionstamp&gt; stampTask) = await db.ReadWriteAsync((tr) =&gt;\n{\n     Slice val = await tr.Get('SOME_KEY', ....);\n\n     tr.SetVersionstampedKey(MAKE_KEY_WITH_VERSION_STAMP(), ..);\n\n     return (val, tr.GetVersionstamp());\n}, cancel);\n\nVersionstamp stamp = await stampTask; // still need an extra await here\n</code></pre>\n<p>I <em>think</em> what the user would expect to happen is that the retry loops returns the Versionstamp directly not a Future:</p>\n<pre data-code-wrap=\"csharp\"><code class=\"lang-csharp\">(Slice result, Versionstamp stamp) = await db.ReadWriteAsync((tr) =&gt;\n{\n     Slice val = await tr.Get('SOME_KEY', ....);\n\n     tr.SetVersionstampedKey(MAKE_KEY_WITH_VERSION_STAMP(), ..);\n\n     return (val, tr.GetVersionstamp());\n}, cancel);\n</code></pre>\n<p>The inner lambda would have signature <code>Func&lt;IFdbTransaction, Task&lt;TResult, Task&lt;VersionStamp&gt;&gt;&gt;</code>, which is a mouthfull, The retryloop method wants to return a <code>Task&lt;TResult, VersionStamp&gt;</code>, and not a <code>Task&lt;TResult, Task&lt;Versionstamp&gt;&gt;</code> so some generic magic needs to be done.</p>\n<p>It may have some effects on the overall API because, in .NET, you cannot have overloads whose signature only differ by the return value. So it would not be easy to have an overload of <code>ReadWriteAsync(...)</code> that returns plain results, and another one which also return a tuple with the resolved timestamp. You\u2019d probably have to change the method name, or add some arguments to disambiguate.</p>\n<p>I <em>could</em> have a <code>ReadWriteWithVersionStampAsync&lt;TResult&gt;() =&gt; Task&lt;(TResult, VersionStamp&gt;)</code> overload, but then it may cause issue when composing multiple libraries:</p>\n<blockquote>\n<p>Let\u2019s say in an HTTP request controller, the outer scope starts a retry loop, and then pass along the transaction to some business logic, which then calls into other Layers (Document, Blob, Index, \u2026). If one layer is refactored somehow, and starts using versionstamps. It would have an impact on the outerscope (in the HTTP controller code) because it needs to <em>know</em> to call GetVersionstamp, <em>before</em> the commit, and extract the value <em>after</em> it has suceeded, and <em>outside</em> the scope of the retry loop. How do I pass back the actual versionstamp into the original layer (which has long since returned and be garbage collected).</p>\n</blockquote>\n<p>It looks like you need dedicated transactions that are fully handled by the Layer code, and will not be able to compose with other layer inside a single transaction ?</p>",
        "post_number": 7,
        "post_type": 1,
        "posts_count": 25,
        "updated_at": "2018-04-25T08:51:14.872Z",
        "reply_count": 1,
        "reply_to_post_number": 5,
        "quote_count": 1,
        "incoming_link_count": 5,
        "reads": 102,
        "readers_count": 101,
        "score": 50.4,
        "yours": false,
        "topic_id": 250,
        "topic_slug": "implementing-versionstamps-in-bindings",
        "display_username": "Christophe Chevalier",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "link_counts": [
          {
            "url": "https://forums.foundationdb.org/t/versioning-of-special-key-space/2068/57",
            "internal": true,
            "reflection": true,
            "title": "Versioning of special key space",
            "clicks": 0
          }
        ],
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 53,
        "hidden": false,
        "trust_level": 2,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/implementing-versionstamps-in-bindings/250/7",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 574,
        "name": "A.J. Beamon",
        "username": "ajbeamon",
        "avatar_template": "/user_avatar/forums.foundationdb.org/ajbeamon/{size}/13_2.png",
        "created_at": "2018-04-25T13:52:30.586Z",
        "cooked": "<aside class=\"quote no-group\" data-username=\"KrzysFR\" data-post=\"7\" data-topic=\"250\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/krzysfr/48/43_2.png\" class=\"avatar\"> KrzysFR:</div>\n<blockquote>\n<p>Let\u2019s say in an HTTP request controller, the outer scope starts a retry loop, and then pass along the transaction to some business logic, which then calls into other Layers (Document, Blob, Index, \u2026). If one layer is refactored somehow, and starts using versionstamps. It would have an impact on the outerscope (in the HTTP controller code) because it needs to know to call GetVersionstamp, before the commit, and extract the value after it has suceeded, and outside the scope of the retry loop.</p>\n</blockquote>\n</aside>\n<p>I may be misunderstanding what you\u2019re saying here, but I think this is a good illustration for why get_versionstamp works the way it does. If one of the layers needs the versionstamp but isn\u2019t responsible for committing, it can call get_versionstamp anyway and the returned future will be set when the transaction ultimately commits at a higher level.</p>\n<aside class=\"quote no-group\" data-username=\"KrzysFR\" data-post=\"7\" data-topic=\"250\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/krzysfr/48/43_2.png\" class=\"avatar\"> KrzysFR:</div>\n<blockquote>\n<p>How do I pass back the actual versionstamp into the original layer (which has long since returned and be garbage collected).</p>\n</blockquote>\n</aside>\n<p>If the layer is going to use the versionstamp of a transaction, it has to be around in some form after the commit completes. If it\u2019s not, what\u2019s the use-case for needing it?</p>",
        "post_number": 8,
        "post_type": 1,
        "posts_count": 25,
        "updated_at": "2018-04-25T13:52:30.586Z",
        "reply_count": 1,
        "reply_to_post_number": 7,
        "quote_count": 1,
        "incoming_link_count": 0,
        "reads": 82,
        "readers_count": 81,
        "score": 21.4,
        "yours": false,
        "topic_id": 250,
        "topic_slug": "implementing-versionstamps-in-bindings",
        "display_username": "A.J. Beamon",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": true,
        "staff": true,
        "user_id": 12,
        "hidden": false,
        "trust_level": 4,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/implementing-versionstamps-in-bindings/250/8",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 589,
        "name": "Christophe Chevalier",
        "username": "KrzysFR",
        "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
        "created_at": "2018-04-25T21:07:24.734Z",
        "cooked": "<aside class=\"quote no-group\" data-username=\"ajbeamon\" data-post=\"8\" data-topic=\"250\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/ajbeamon/48/13_2.png\" class=\"avatar\"> ajbeamon:</div>\n<blockquote>\n<p>If the layer is going to use the versionstamp of a transaction, it has to be around in some form after the commit completes. If it\u2019s not, what\u2019s the use-case for needing it?</p>\n</blockquote>\n</aside>\n<p>You\u2019re right, but I guess the issue comes from how you would write this using using idiomatic .NET with async/await.</p>\n<p>Let\u2019s say I have a very simple WEB API controller, that create versionstamped keys but doesn\u2019t need to know their value. This is nice and simple with the current API. <em>note: I\u2019m assuming that encoding of version stamps at the tuple layer is magical and just works. outside the scope of this sample</em></p>\n<pre><code class=\"lang-auto\">public class SomeApiController\n{\n\t#region Stuff..\n        // all initialized from the Web Application via HttpContext and DI...\n\tprivate IFdbDatabase Db;\n\tprivate CancellationToken Cancellation;\n\tprivate IDynamicKeySubspace Location;\n\tprivate string DoSomethingWithIt(Slice data) =&gt; \"hello\";\n\t#endregion\n\n\t// REST EndPoint\n\tpublic async Task&lt;SomeResult&gt; SomeRestMethod(Guid id)\n\t{\n\t\t// here is the \"business logic\"\n\t\tvar data = await this.Db.ReadWriteAsync(async (tr) =&gt;\n\t\t{\n\t\t\t// read a key\n\t\t\tvar val = await tr.GetAsync(this.Location.Keys.Encode(\"A\", id));\n\n\t\t\t// create stamped keys\n\t\t\ttr.SetVersionStampedKey(this.Location.Keys.Encode(\"B\", tr.CreateStamp(1)), Slice.FromString(\"some_value\"));\n\t\t\ttr.SetVersionStampedKey(this.Location.Keys.Encode(\"B\", tr.CreateStamp(2)), Slice.FromString(\"some_other_value\"));\n\n\t\t\treturn val;\n\t\t}, this.Cancellation);\n\n\t\t// return\n\t\treturn new SomeResult { Foo = DoSomethingWithIt(data) };\n\t}\n}\n</code></pre>\n<p>I would NOT want to write something like this:</p>\n<pre><code class=\"lang-auto\">await this.Db.ReadWriteAsync(async (tr) =&gt;\n{\n\t// read a key\n\tvar val = await tr.GetAsync(this.Location.Keys.Encode(\"A\", id));\n\n\t// create stamped keys\n\ttr.SetVersionStampedKey(this.Location.Keys.Encode(\"B\", tr.CreateStamp(1)), Slice.FromString(\"some_value\"));\n\ttr.SetVersionStampedKey(this.Location.Keys.Encode(\"B\", tr.CreateStamp(2)), Slice.FromString(\"some_other_value\"));\n\n\ttr.GetVersionStampAsync()\n\t  .ContinueWith((t) =&gt;\n\t{ // this runs somewhere on the ThreadPool, at any time in the future!\n\t\tvar stamp = t.Resut;\n\t\tDoSomethingWithId(data, stamp);\n\t}); // =&gt; if it fails, nobody will know about it!\n);\n}, this.Cancellation);\n</code></pre>\n<p>The Task continuation runs on another thread, maybe later, long after the HTTP context has been collected. And also it as no way to send it back to the client and could throw exceptions into nowhere</p>\n<p>Now if I want to pass the actual versionstamp outside the scope of the retry loop and back to the controller while the HTTP context is still alive, I could try to change it like this, which is at least still using async/await:</p>\n<pre><code class=\"lang-auto\">// REST EndPoint\npublic async Task&lt;SomeResult&gt; SomeRestMethod(Guid id)\n{\n\n        // first part of the business logic (that talks to the db)\n\t(Slice data, Task&lt;VersionStamp&gt; stampTask) = await this.Db.ReadWriteAsync(async (tr) =&gt;\n\t{\n\t\t// read a key\n\t\tvar val = await tr.GetAsync(this.Location.Keys.Encode(\"A\", id));\n\n\t\t// create stamped keys\n\t\ttr.SetVersionStampedKey(this.Location.Keys.Encode(\"B\", tr.CreateStamp(1)), Slice.FromString(\"some_value\"));\n\t\ttr.SetVersionStampedKey(this.Location.Keys.Encode(\"B\", tr.CreateStamp(2)), Slice.FromString(\"some_other_value\"));\n\n\t\treturn (val, tr.GetVersionStampAsync());\n\t}, this.Cancellation);\n\t\n\t// need another await\n\tVersionStamp stamp = await stampTask; // &lt;-- this is ugly!\n\tvar foo = DoSomethingWithIt(data, stamp); // hidden in here is the second part of the business logic\n\n\t// return\n\treturn new SomeResult { Foo = foo };\n}\n</code></pre>\n<p>But the actual business logic is split in two: the retry loop is doing the first part of the job, but then the actual \u201cfinish\u201d is in this <em>DoSomethingWithIt</em>, which has to <em>know</em> that I used two stamps with user version 1 &amp; 2. Also, the outer controller code has to act as the middle man, and also do the task resolving to get the stamp. =&gt; this is very tied to the implementation (using FoundationDB) and may not be easy to abstract away.</p>\n<p>After playing a bit with it, I think the ideal would be to add an <em><code>onSuccess</code></em> handler on the retry loop logic, that gets called once the transction commits, and is passed the result of the inner handler, plus the resolved versionstamp. It can then consume and post-process the stamp.</p>\n<pre><code class=\"lang-auto\">// REST EndPoint\npublic async Task&lt;SomeResult&gt; SomeRestMethod(Guid id)\n{\n\n\tvar foo = await this.Db.ReadWriteAsync(\n\t\thandler: async (tr) =&gt;\n\t\t{ // this part runs inside the transaction, and can be retried multiple times\n\n\t\t\t// read a key\n\t\t\tvar val = await tr.GetAsync(this.Location.Keys.Encode(\"A\", id));\n\n\t\t\t// create stamped keys\n\t\t\ttr.SetVersionStampedKey(this.Location.Keys.Encode(\"B\", tr.CreateStamp(1)), Slice.FromString(\"some_value\"));\n\t\t\ttr.SetVersionStampedKey(this.Location.Keys.Encode(\"B\", tr.CreateStamp(2)), Slice.FromString(\"some_other_value\"));\n\n\t\t\treturn val;\n\t\t},\n\t\tsuccess: (val, stamp) =&gt;\n\t\t{ // this parts runs at most once, after the transaction has committed succesfully.\n\t\t\treturn DoSomethingWithIt(val, stamp);\n\t\t},\n\t\tct: this.Cancellation\n\t);\n\n\t// no additional fdb-specific logic here!\n\n\treturn new SomeResult { Foo = foo };\n}\n</code></pre>\n<p>Everything stamp relative is handled inside <code>ReadWriteAsync()</code>, and the result is the complete post-processed thing.</p>\n<p>If I refactor this further, then no more fdb-logic is visible inside the controller itself</p>\n<pre><code class=\"lang-auto\">public class SomeApiController\n{\n\t#region Stuff..\n\tprivate IFdbDatabase Db;\n\tprivate CancellationToken Cancellation;\n\t#endregion\n\n\t// REST EndPoint\n\tpublic async Task&lt;SomeResult&gt; SomeRestMethod(Guid id)\n\t{\n\t\tvar engine = new MyBusinessLogicEngine(/*...*/);\n\n\t\tvar result = await engine.DealWithIt(this.Db, id, this.Cancellation);\n\t\t// no additional fdb-specific logic here!\n\t\treturn new SomeResult { Foo = result };\n\t}\n}\n\n// library in a different assembly somewhere\npublic class MyBusinessLogicEngine\n{\n\tprivate IDynamicKeySubspace Location;\n\n\tpublic Task&lt;string&gt; DealWithIt(IFdbDatabase db, Guid id, CancellationToken ct)\n\t{\n\t\treturn db.ReadWriteAsync(\n\t\t\thandler: async (tr) =&gt;\n\t\t\t{ // this part runs inside the transaction, and can be retried multiple times\n\n\t\t\t\t// read a key\n\t\t\t\tvar val = await tr.GetAsync(this.Location.Keys.Encode(\"A\", id));\n\n\t\t\t\t// create stamped keys\n\t\t\t\ttr.SetVersionStampedKey(this.Location.Keys.Encode(\"B\", tr.CreateStamp(1)), Slice.FromString(\"some_value\"));\n\t\t\t\ttr.SetVersionStampedKey(this.Location.Keys.Encode(\"B\", tr.CreateStamp(2)), Slice.FromString(\"some_other_value\"));\n\n\t\t\t\treturn val;\n\t\t\t},\n\t\t\tsuccess: (val, stamp) =&gt;\n\t\t\t{ // this parts runs at most once, after the transaction has committed succesfully.\n\n\t\t\t\t// second part of the business logic\n\t\t\t\treturn \"hello:\" + val + \":\" + stamp;\n\t\t\t},\n\t\t\tct: ct\n\t\t);\n\t}\n\n}\n</code></pre>\n<p>But now, the method in the Business Logic class takes in a Database instance, and not a Transaction, so it cannot compose well with <em>another</em> layer that could read/write some keys at the same time.</p>\n<p>I\u2019ve seen this issue happening a lot in the last few years: the web controller has the db and is supposed to orchestrate everything in a single transaction to reduce latency. But all the various other libraries underneath will try open their own transactions in parallel. Sometimes by laziness, but sometimes by necessity (like a Blob Layer that has to upload more than 10 MB, or here deeply nested code that needs execute <em>after</em> the transaction completes, but <em>before</em> the controller gets back the result).</p>\n<p>So by \u201cnot composing\u201d well, I mean that now code inside retry loops has to take the responsibility of handling the lifetime of the transaction, and/or interleave part of its code back up the callstack, while keeping all its own scope (arguments, variables, context objects) it allocated alive long enough.</p>",
        "post_number": 9,
        "post_type": 1,
        "posts_count": 25,
        "updated_at": "2018-04-25T21:07:24.734Z",
        "reply_count": 2,
        "reply_to_post_number": 8,
        "quote_count": 1,
        "incoming_link_count": 8,
        "reads": 94,
        "readers_count": 93,
        "score": 68.8,
        "yours": false,
        "topic_id": 250,
        "topic_slug": "implementing-versionstamps-in-bindings",
        "display_username": "Christophe Chevalier",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "link_counts": [
          {
            "url": "https://forums.foundationdb.org/t/versionstamp-vs-committedversion/600",
            "internal": true,
            "reflection": true,
            "title": "VersionStamp vs CommittedVersion",
            "clicks": 1
          }
        ],
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 53,
        "hidden": false,
        "trust_level": 2,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/implementing-versionstamps-in-bindings/250/9",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 594,
        "name": "Sam Pullara",
        "username": "spullara",
        "avatar_template": "/user_avatar/forums.foundationdb.org/spullara/{size}/125_2.png",
        "created_at": "2018-04-25T22:08:06.381Z",
        "cooked": "<p>I ran into a similar problem today. I am able to use Database.run() to get the versionstamp as it returns the CompletableFuture&lt;byte[]&gt; and then I can wait for it and get the value. However, if I use Database.runAsync() it gets pretty ugly but I think I found the pattern for it. Not really reporting a bug, just agreeing that it is can be a little painful to get the versionstamp out of there if you need it.</p>\n<p>Works:</p>\n<pre><code class=\"lang-java\">    byte[] versionstamp = open.run(tx -&gt; {\n      byte[] key = ds.get(\"test\").packWithVersionstamp(Tuple.from(Versionstamp.incomplete()));\n      tx.mutate(SET_VERSIONSTAMPED_KEY, key, \"test\".getBytes());\n      return tx.getVersionstamp();\n    }).get();\n</code></pre>\n<p>Deadlocks, for good reason:</p>\n<pre><code class=\"lang-java\">    byte[] versionstamp = open.runAsync(tx -&gt; {\n      byte[] key = ds.get(\"test\").packWithVersionstamp(Tuple.from(Versionstamp.incomplete()));\n      tx.mutate(SET_VERSIONSTAMPED_KEY, key, \"test\".getBytes());\n      return tx.getVersionstamp();\n    }).get();\n</code></pre>\n<p>Cannot access closed object:</p>\n<pre><code class=\"lang-java\">    byte[] versionstamp = open.runAsync(tx -&gt; {\n      byte[] key = ds.get(\"test\").packWithVersionstamp(Tuple.from(Versionstamp.incomplete()));\n      tx.mutate(SET_VERSIONSTAMPED_KEY, key, \"test\".getBytes());\n      return CompletableFuture.completedFuture(tx);\n    }).get().getVersionstamp().get();\n\nOR\n\n    byte[] versionstamp = open.runAsync(tx -&gt; {\n      byte[] key = ds.get(\"test\").packWithVersionstamp(Tuple.from(Versionstamp.incomplete()));\n      tx.mutate(SET_VERSIONSTAMPED_KEY, key, \"test\".getBytes());\n      return CompletableFuture.completedFuture(tx);\n    }).thenApply(Transaction::getVersionstamp).get().get();\n\n</code></pre>\n<p>Awkward but works:</p>\n<pre><code class=\"lang-java\">    byte[] versionstamp = open.runAsync(tx -&gt; {\n      byte[] key = ds.get(\"test\").packWithVersionstamp(Tuple.from(Versionstamp.incomplete()));\n      tx.mutate(SET_VERSIONSTAMPED_KEY, key, \"test\".getBytes());\n      return CompletableFuture.completedFuture(tx.getVersionstamp());\n    }).get().get();\n</code></pre>",
        "post_number": 10,
        "post_type": 1,
        "posts_count": 25,
        "updated_at": "2018-04-25T22:08:06.381Z",
        "reply_count": 1,
        "reply_to_post_number": 9,
        "quote_count": 0,
        "incoming_link_count": 8,
        "reads": 69,
        "readers_count": 68,
        "score": 58.8,
        "yours": false,
        "topic_id": 250,
        "topic_slug": "implementing-versionstamps-in-bindings",
        "display_username": "Sam Pullara",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "reply_to_user": {
          "id": 53,
          "username": "KrzysFR",
          "name": "Christophe Chevalier",
          "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png"
        },
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 156,
        "hidden": false,
        "trust_level": 2,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/implementing-versionstamps-in-bindings/250/10",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 627,
        "name": "A.J. Beamon",
        "username": "ajbeamon",
        "avatar_template": "/user_avatar/forums.foundationdb.org/ajbeamon/{size}/13_2.png",
        "created_at": "2018-04-26T18:05:47.468Z",
        "cooked": "<aside class=\"quote no-group quote-modified\" data-username=\"KrzysFR\" data-post=\"9\" data-topic=\"250\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/krzysfr/48/43_2.png\" class=\"avatar\"> KrzysFR:</div>\n<blockquote>\n<p>(Slice data, Task&lt;VersionStamp&gt; stampTask) = await this.Db.ReadWriteAsync(async (tr) =&gt;<br>\n{<br>\n// read a key<br>\nvar val = await tr.GetAsync(this.Location.Keys.Encode(\u201cA\u201d, id));</p>\n<pre><code>\t// create stamped keys\n\ttr.SetVersionStampedKey(this.Location.Keys.Encode(\"B\", tr.CreateStamp(1)), Slice.FromString(\"some_value\"));\n\ttr.SetVersionStampedKey(this.Location.Keys.Encode(\"B\", tr.CreateStamp(2)), Slice.FromString(\"some_other_value\"));\n\n\treturn (val, tr.GetVersionStampAsync());\n}, this.Cancellation);\n\n// need another await\nVersionStamp stamp = await stampTask; // &amp;lt;-- this is ugly!\n</code></pre>\n</blockquote>\n</aside>\n<p>I think this is one of the expected ways that you would use a versionstamp. The versionstamp result cannot be known while the transaction is uncommitted, so the return value of a call to get the versionstamp is a future to be set after the commit succeeds or fails. I believe it\u2019s the case that this future is set as part of the commit, so in that particular example (and all of Sam\u2019s examples, assuming <code>open</code> is a database), the future will already be ready at the point where you are waiting on it. It seems possible to provide an API in the bindings that could accomplish the same thing in this case without requiring a second wait if you wanted (e.g. by having another version of the run loop that returns a versionstamp or something, though it could only work on a database).</p>\n<p>Also, I don\u2019t know if there\u2019s a reason that get_versionstamp must be called before commit, but if not then perhaps it could be changed so that you could get the versionstamp future after commit as well. It doesn\u2019t really help in these retry loop examples you and Sam gave, though, because you don\u2019t have access to the transaction outside of the loop.</p>\n<aside class=\"quote no-group\" data-username=\"KrzysFR\" data-post=\"9\" data-topic=\"250\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/krzysfr/48/43_2.png\" class=\"avatar\"> KrzysFR:</div>\n<blockquote>\n<p>tr.GetVersionStampAsync()<br>\n.ContinueWith((t) =&gt;<br>\n{ // this runs somewhere on the ThreadPool, at any time in the future!<br>\nvar stamp = t.Resut;<br>\nDoSomethingWithId(data, stamp);<br>\n}); // =&gt; if it fails, nobody will know about it!</p>\n</blockquote>\n</aside>\n<p>It sounds like you are trying to design for a case where you have a layer API that has some sort of request that takes a transaction (i.e. doesn\u2019t do the commit itself) but wants to do work both in and after the transaction and not return to the root caller until it\u2019s done with all of that.  I agree that our FoundationDB client and our other bindings don\u2019t provide that capability, so at least based on the current API you would have to design your layer\u2019s API accordingly. For example, you may have to make multiple calls into the API or return a value from your request function that will signify once the request is fully complete.</p>\n<p>Commit hooks could be useful in this and other scenarios, so it may be worth posing that as its own specific feature request.</p>",
        "post_number": 11,
        "post_type": 1,
        "posts_count": 25,
        "updated_at": "2018-04-26T18:05:47.468Z",
        "reply_count": 1,
        "reply_to_post_number": 9,
        "quote_count": 1,
        "incoming_link_count": 2,
        "reads": 69,
        "readers_count": 68,
        "score": 28.8,
        "yours": false,
        "topic_id": 250,
        "topic_slug": "implementing-versionstamps-in-bindings",
        "display_username": "A.J. Beamon",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": true,
        "staff": true,
        "user_id": 12,
        "hidden": false,
        "trust_level": 4,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/implementing-versionstamps-in-bindings/250/11",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 628,
        "name": "Christophe Chevalier",
        "username": "KrzysFR",
        "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
        "created_at": "2018-04-26T18:52:34.853Z",
        "cooked": "<p>I think one the confusing aspect is that the method returns a Future like most other operations on a transaction, but it cannot be resolved until after the commit Future has resolved, unlike any other operations. The only other similar thing I can think of are Watches, which outlive the transaction scope.</p>\n<p>Also, there is already one property, the commited version, which only exists after the commit, but this one is not exposed as a Future: you call <code>fdb_transaction_get_committed_version</code> and get the result immediately (or an error if you called it too soon). Couldn\u2019t we have a similar system for the stamps?</p>\n<p>Maybe if requesting the versionstamp has some overhead when committing, it could require some option to be set, like <code>AUTO_RESOLVE_VERSIONSTAMPS</code>? Once the commit succeeds, then querying the versionstamp accessor would return the value (or an error) just like <code>fdb_transaction_get_committed_version</code> does today.</p>\n<p>This would at least give a more straight-forward view of the workflow: you do your thing with the transaction (get, set, clear, \u2026) and maybe versionstamp some keys. You need the actual value used, it will be something that you call <em>after</em> a successfull commit. Not half-before, half-after.</p>\n<p>Like you said, if the Future is resolved at the same time as the commit\u2019s Future, then it could be a simple value accessor, no ?</p>\n<p>Then, for retry loops, the remaining issue to resolve, is how can we create a small window of execution that happens after the commit, but before the retry loop yields to the caller (and destroy the context).</p>\n<p>This could be done with a <code>onSuccess</code> lambda executed after commit, or maybe you could register callbacks on the transaction instance itself?</p>\n<p>I\u2019m not fond of the later, because it can lead to bad-practice pattern (in .NET, probably similar in other languages) were the callback will create a new scope that will capture all the variables and state of the outer scope, and could keep a lot of objects and state alive for no reason that the GC cannot collect.</p>\n<pre><code class=\"lang-auto\">await db.ReadWriteAsync((tr) =&gt;\n{\n     // outer scope that can allocate large keys and values (byte[])\n     byte[] evil_buffer = new byte[100_000_000_000]; // will be captured by inner scope!\n     // serialize keys, call tr.SetVersionStampedKey(...), etc...\n\n     tr.OnCommitted((state) =&gt; \n     { // inner scope\n\n          var commitVersion = state.CommitVerison;\n          var stamp = state.VersionStamp;\n          // Do something with it!\n     }\n}, ...);\n</code></pre>\n<p>The inner scope will capture all the variables in the outer scope, so the <code>evil_buffer</code> may be kept alive for more time than required (GC cannot guess if it is still alive). <em>This is a current limitation of the Roslyn .NET compiler that merge all scopes inside a method into a single container that aggregates all the state in the heap in the same instance. Not sure about Java or other</em></p>\n<p>The only way I know out of this, is to extract each inner scope into a different method, and call them. This leads to broken code with pieces of scopes everywhere.</p>\n<p><em>I\u2019ve been bitten by this so many times, maybe that\u2019s why I\u2019m so uneasy with this API pattern!</em> <img src=\"https://emoji.discourse-cdn.com/twitter/slight_smile.png?v=5\" title=\":slight_smile:\" class=\"emoji\" alt=\":slight_smile:\"></p>",
        "post_number": 12,
        "post_type": 1,
        "posts_count": 25,
        "updated_at": "2018-04-26T18:54:49.990Z",
        "reply_count": 1,
        "reply_to_post_number": 11,
        "quote_count": 0,
        "incoming_link_count": 1,
        "reads": 68,
        "readers_count": 67,
        "score": 23.6,
        "yours": false,
        "topic_id": 250,
        "topic_slug": "implementing-versionstamps-in-bindings",
        "display_username": "Christophe Chevalier",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "reply_to_user": {
          "id": 12,
          "username": "ajbeamon",
          "name": "A.J. Beamon",
          "avatar_template": "/user_avatar/forums.foundationdb.org/ajbeamon/{size}/13_2.png"
        },
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 53,
        "hidden": false,
        "trust_level": 2,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/implementing-versionstamps-in-bindings/250/12",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 629,
        "name": "Christophe Chevalier",
        "username": "KrzysFR",
        "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
        "created_at": "2018-04-26T18:58:43.657Z",
        "cooked": "<p>I have a PR opened with my current work in progress here <a href=\"https://github.com/Doxense/foundationdb-dotnet-client/pull/72\" rel=\"nofollow noopener\">https://github.com/Doxense/foundationdb-dotnet-client/pull/72</a></p>\n<p>I\u2019m trying out an alternative way of serializing of versionstamps, without active support required from the encoders (tuple layer, etc\u2026), using the random tokens idea I described above. It looks like it will simplify things a lot.</p>",
        "post_number": 13,
        "post_type": 1,
        "posts_count": 25,
        "updated_at": "2018-04-26T18:58:43.657Z",
        "reply_count": 0,
        "reply_to_post_number": null,
        "quote_count": 0,
        "incoming_link_count": 0,
        "reads": 64,
        "readers_count": 63,
        "score": 12.8,
        "yours": false,
        "topic_id": 250,
        "topic_slug": "implementing-versionstamps-in-bindings",
        "display_username": "Christophe Chevalier",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "link_counts": [
          {
            "url": "https://github.com/Doxense/foundationdb-dotnet-client/pull/72",
            "internal": false,
            "reflection": false,
            "title": "Add support for VersionStamps by KrzysFR \u00b7 Pull Request #72 \u00b7 Doxense/foundationdb-dotnet-client \u00b7 GitHub",
            "clicks": 3
          }
        ],
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 53,
        "hidden": false,
        "trust_level": 2,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/implementing-versionstamps-in-bindings/250/13",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 631,
        "name": "A.J. Beamon",
        "username": "ajbeamon",
        "avatar_template": "/user_avatar/forums.foundationdb.org/ajbeamon/{size}/13_2.png",
        "created_at": "2018-04-26T19:44:50.670Z",
        "cooked": "<aside class=\"quote no-group\" data-username=\"KrzysFR\" data-post=\"12\" data-topic=\"250\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/krzysfr/48/43_2.png\" class=\"avatar\"> KrzysFR:</div>\n<blockquote>\n<p>you call fdb_transaction_get_committed_version and get the result immediately (or an error if you called it too soon). Couldn\u2019t we have a similar system for the stamps?</p>\n</blockquote>\n</aside>\n<p>In most (all?) of the examples posed in this thread, there was no transaction object to make this call on after the commit because of the use of the retry loops.</p>",
        "post_number": 14,
        "post_type": 1,
        "posts_count": 25,
        "updated_at": "2018-04-26T19:44:50.670Z",
        "reply_count": 1,
        "reply_to_post_number": 12,
        "quote_count": 1,
        "incoming_link_count": 0,
        "reads": 60,
        "readers_count": 59,
        "score": 17.0,
        "yours": false,
        "topic_id": 250,
        "topic_slug": "implementing-versionstamps-in-bindings",
        "display_username": "A.J. Beamon",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": true,
        "staff": true,
        "user_id": 12,
        "hidden": false,
        "trust_level": 4,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/implementing-versionstamps-in-bindings/250/14",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 637,
        "name": "Christophe Chevalier",
        "username": "KrzysFR",
        "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
        "created_at": "2018-04-26T20:29:35.429Z",
        "cooked": "<aside class=\"quote no-group\" data-username=\"ajbeamon\" data-post=\"14\" data-topic=\"250\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/ajbeamon/48/13_2.png\" class=\"avatar\"> ajbeamon:</div>\n<blockquote>\n<p>In most (all?) of the examples posed in this thread, there was no transaction object to make this call on after the commit because of the use of the retry loops.</p>\n</blockquote>\n</aside>\n<p>That\u2019s true, I was thinking that the retry loop machinery would be able to do this automatically.</p>\n<p>My current thinking is that using one the the vesionstamped atomic operations would set a flag. Once the transaction need to be commited, and if this flag is set, the retry loop would also request the versionstamp as well, and hide the task internally. The result would then be exposed to the caller via some mechanism, either via a second \u2018onSuccess\u2019 lambda that is invoked with the result of the loop body plus the resolved stamp, or via some other way (shared \u2018context\u2019 object? a fat \u2018result\u2019 object with multiple properties?)</p>\n<p>If getting the resolved versionstamp from the transaction is cheap enough, I can do this automatically even if the caller doesn\u2019t need it. If this has a non-trivial cost, then I would need to add some setting or option to trigger this.</p>\n<p>If the only cost is having to create a Future handle, then I could maybe try to optimize this case by delaying the allocation of all the interop machinery in the binding (only alloation the FutureHandle, not the tasks and callbacks).</p>\n<p>This could make it so that I can use the existing low level C API, and attempt to guide users of the .NET binding into patterns that are less prone to allocations and potential deadlocks.</p>\n<p>I would not want to artificially slow down the very fast path of code that just wants to add a message on some queue (using versionstamps) and that doesn\u2019t care about the stamp itself. If the overhead is a couple % who cares, but if it is more, then I really need to make this opt-in.</p>",
        "post_number": 15,
        "post_type": 1,
        "posts_count": 25,
        "updated_at": "2018-04-26T20:29:35.429Z",
        "reply_count": 1,
        "reply_to_post_number": 14,
        "quote_count": 1,
        "incoming_link_count": 0,
        "reads": 61,
        "readers_count": 60,
        "score": 17.2,
        "yours": false,
        "topic_id": 250,
        "topic_slug": "implementing-versionstamps-in-bindings",
        "display_username": "Christophe Chevalier",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 53,
        "hidden": false,
        "trust_level": 2,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/implementing-versionstamps-in-bindings/250/15",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 639,
        "name": "A.J. Beamon",
        "username": "ajbeamon",
        "avatar_template": "/user_avatar/forums.foundationdb.org/ajbeamon/{size}/13_2.png",
        "created_at": "2018-04-26T21:27:41.581Z",
        "cooked": "<p>Ah, I see. I thought your request was for a change to the C API, so my comment was in regard to that. Certainly the bindings can provide other features on top of that to make various patterns easier. I don\u2019t think that there\u2019s much extra cost to requesting the versionstamp needlessly, as it appears that the call just returns a future that\u2019s being set regardless.</p>",
        "post_number": 16,
        "post_type": 1,
        "posts_count": 25,
        "updated_at": "2018-04-26T21:27:41.581Z",
        "reply_count": 0,
        "reply_to_post_number": 15,
        "quote_count": 0,
        "incoming_link_count": 0,
        "reads": 57,
        "readers_count": 56,
        "score": 11.4,
        "yours": false,
        "topic_id": 250,
        "topic_slug": "implementing-versionstamps-in-bindings",
        "display_username": "A.J. Beamon",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "reply_to_user": {
          "id": 53,
          "username": "KrzysFR",
          "name": "Christophe Chevalier",
          "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png"
        },
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": true,
        "staff": true,
        "user_id": 12,
        "hidden": false,
        "trust_level": 4,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/implementing-versionstamps-in-bindings/250/16",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 646,
        "name": "Seph Gentle",
        "username": "josephg",
        "avatar_template": "/user_avatar/forums.foundationdb.org/josephg/{size}/84_2.png",
        "created_at": "2018-04-27T04:49:52.296Z",
        "cooked": "<p>For what its worth, this is all quite fun with the new nodejs bindings too. I suspect that with the introduction of promises &amp; async/await the new node bindings are going to be similar to the C# bindings in many ways.</p>\n<p>Deadlocks:</p>\n<pre><code class=\"lang-javascript\">  const stamp = await db.doTransaction(async tn =&gt; {\n    tn.setVersionstampedValue('x', Buffer.from([1,2,1,2,1,2,1,2,1,2]))\n    return tn.getVersionStamp()\n  }) // DEADLOCKS\n</code></pre>\n<p>\u2026 When an async function returns a promise, it automatically unwraps the inner promise before returning. Thus that code waits for the <code>tn.getVersionStamp()</code> promise internally, which deadlocks.</p>\n<p>But you can trivially avoid that behaviour using awful hacks, like wrapping the stamp in an array:</p>\n<pre><code class=\"lang-javascript\">  const stampArr = await db.doTransaction(async tn =&gt; {\n    tn.setVersionstampedValue('x', Buffer.from([1,2,1,2,1,2,1,2,1,2]))\n    return [tn.getVersionStamp()]\n  })\n  const stamp = await stampArr[0] // WORKS\n</code></pre>\n<p>I\u2019m not sure what the best approach is here. JS might following what you end up doing in the C# bindings.</p>",
        "post_number": 17,
        "post_type": 1,
        "posts_count": 25,
        "updated_at": "2018-04-27T04:49:52.296Z",
        "reply_count": 0,
        "reply_to_post_number": null,
        "quote_count": 0,
        "incoming_link_count": 4,
        "reads": 66,
        "readers_count": 65,
        "score": 33.2,
        "yours": false,
        "topic_id": 250,
        "topic_slug": "implementing-versionstamps-in-bindings",
        "display_username": "Seph Gentle",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 120,
        "hidden": false,
        "trust_level": 2,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/implementing-versionstamps-in-bindings/250/17",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 665,
        "name": "David Scherer",
        "username": "dave",
        "avatar_template": "/user_avatar/forums.foundationdb.org/dave/{size}/89_2.png",
        "created_at": "2018-04-27T19:27:13.136Z",
        "cooked": "<p>I don\u2019t think that switching to have a synchronous get_versionstamp() after commit would actually make any of these issues easier.  If you do want that, I think you can have it by just <em>blocking</em> on the future after the transaction commits; I think that is in fact guaranteed to complete quickly enough to tolerate for even a single threaded event loop.</p>\n<p>I think the composable way to build operations with versionstamps is roughly like this (apologies if my hand-written C# doesn\u2019t compile)</p>\n<pre><code>public Task&lt; (LogicalResult, Task&lt;FullId&gt;) &gt; doThing( DatabaseOrTransaction dbtx, Guid id ) {\n    return dbtx.ReadWriteAsync( async (tr) =&gt; {\n        var read = tr.GetAsync( this.Location.Keys.Encode(\"A\", id) );\n        tr.SetVersionStampedKey( this.Location.Keys.Encode(\"B\", tr.CreateStamp(1)), id );\n        LogicalResult lr = computeLogicalResult( id, await read );\n        var fullId = computeFullId( id, tr.GetVersionStampAsync() );\n        return (lr, fullId);\n    } );\n}\nprivate async Task&lt;FullId&gt; computeFullId( Guid id, Task&lt;VersionStamp&gt; stamp ) {\n    return new FullId { part1 = id, part2 = await stamp });\n}\n</code></pre>\n<p>Of course you can make computeFullId() an async lambda if you don\u2019t want to name it.</p>\n<p>You should be able to combine multiple things like this in a transaction, including doing them in parallel if they don\u2019t otherwise conflict.  You can easily call it on a database as well.  The logic for exactly what the versionstamp means (and even that a versionstamp is used at all) is safely located inside doThing().  The caller is responsible for not waiting on the Task until you are definitely outside a transaction context, but that is just a fundamental requirement of using versionstamps (or watches, which are very similar).  And for the same reason I think it is kind of fundamentally needed for the return value of an operation like doThing() that you want to be composable to have two parts in some sense - one that you can safely use inside another transaction that is composing doThing(), and one that can only be accessed outside a transaction.</p>",
        "post_number": 18,
        "post_type": 1,
        "posts_count": 25,
        "updated_at": "2018-04-27T19:27:13.136Z",
        "reply_count": 0,
        "reply_to_post_number": null,
        "quote_count": 0,
        "incoming_link_count": 7,
        "reads": 70,
        "readers_count": 69,
        "score": 49.0,
        "yours": false,
        "topic_id": 250,
        "topic_slug": "implementing-versionstamps-in-bindings",
        "display_username": "David Scherer",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 22,
        "hidden": false,
        "trust_level": 1,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/implementing-versionstamps-in-bindings/250/18",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 993,
        "name": "Christophe Chevalier",
        "username": "KrzysFR",
        "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
        "created_at": "2018-05-09T16:27:15.540Z",
        "cooked": "<p><a class=\"mention\" href=\"/u/alloc\">@alloc</a> What is the impact of <a href=\"https://github.com/apple/foundationdb/pull/242\" rel=\"nofollow noopener\">#242 - Unify SET_VERSIONSTAMPED_KEY and SET_VERSIONSTAMPED_VALUE API</a> and <a href=\"https://github.com/apple/foundationdb/issues/148\" rel=\"nofollow noopener\">#148</a> for bindings?</p>\n<p>Looks like, depending on the API version, we will have to specify the offset as 2 or 4 bytes.</p>",
        "post_number": 19,
        "post_type": 1,
        "posts_count": 25,
        "updated_at": "2018-05-09T16:27:41.011Z",
        "reply_count": 1,
        "reply_to_post_number": null,
        "quote_count": 0,
        "incoming_link_count": 0,
        "reads": 64,
        "readers_count": 63,
        "score": 17.8,
        "yours": false,
        "topic_id": 250,
        "topic_slug": "implementing-versionstamps-in-bindings",
        "display_username": "Christophe Chevalier",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "link_counts": [
          {
            "url": "https://github.com/apple/foundationdb/pull/242",
            "internal": false,
            "reflection": false,
            "clicks": 3
          },
          {
            "url": "https://github.com/apple/foundationdb/issues/148",
            "internal": false,
            "reflection": false,
            "title": "Update versionstamp mutation types to make them consistent \u00b7 Issue #148 \u00b7 apple/foundationdb \u00b7 GitHub",
            "clicks": 1
          }
        ],
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 53,
        "hidden": false,
        "trust_level": 2,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/implementing-versionstamps-in-bindings/250/19",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 994,
        "name": "Alec Grieser",
        "username": "alloc",
        "avatar_template": "/user_avatar/forums.foundationdb.org/alloc/{size}/9_2.png",
        "created_at": "2018-05-09T16:49:37.911Z",
        "cooked": "<p>That\u2019s right. If you are a binding maintainer and have decided to implement versionstamps in tuples, the suggestion would be to have it choose whether to add two or four bytes based on the API version. Here\u2019s the line where that\u2019s done in the Java bindings: <a href=\"https://github.com/apple/foundationdb/blob/f3093642b3c1babe93aacbaee8f60b4008662d52/bindings/java/src/main/com/apple/foundationdb/tuple/TupleUtil.java#L583\">https://github.com/apple/foundationdb/blob/f3093642b3c1babe93aacbaee8f60b4008662d52/bindings/java/src/main/com/apple/foundationdb/tuple/TupleUtil.java#L583</a></p>\n<p>The benefit of this change is that once that\u2019s done, the same code can be used to encode data for <code>SET_VERSIONSTAMPED_KEY</code> mutations and <code>SET_VERSIONSTAMPED_VALUE</code> mutations rather than having one mutation take two bytes and the other four. (The alternative alternative would be to have <code>SET_VERSIONSTAMPED_VALUE</code> mutations have a weird limitation that meant that you could place a versionstamp only in the first 65 kB of the value.) I don\u2019t think it should be too painful, but maybe I\u2019m wrong.</p>",
        "post_number": 20,
        "post_type": 1,
        "posts_count": 25,
        "updated_at": "2018-05-09T16:49:37.911Z",
        "reply_count": 1,
        "reply_to_post_number": 19,
        "quote_count": 0,
        "incoming_link_count": 2,
        "reads": 65,
        "readers_count": 64,
        "score": 28.0,
        "yours": false,
        "topic_id": 250,
        "topic_slug": "implementing-versionstamps-in-bindings",
        "display_username": "Alec Grieser",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "link_counts": [
          {
            "url": "https://github.com/apple/foundationdb/blob/f3093642b3c1babe93aacbaee8f60b4008662d52/bindings/java/src/main/com/apple/foundationdb/tuple/TupleUtil.java#L583",
            "internal": false,
            "reflection": false,
            "title": "foundationdb/TupleUtil.java at f3093642b3c1babe93aacbaee8f60b4008662d52 \u00b7 apple/foundationdb \u00b7 GitHub",
            "clicks": 6
          }
        ],
        "read": true,
        "user_title": null,
        "reply_to_user": {
          "id": 53,
          "username": "KrzysFR",
          "name": "Christophe Chevalier",
          "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png"
        },
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 8,
        "hidden": false,
        "trust_level": 4,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/implementing-versionstamps-in-bindings/250/20",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      }
    ],
    "stream": [
      527,
      528,
      531,
      541,
      552,
      560,
      562,
      574,
      589,
      594,
      627,
      628,
      629,
      631,
      637,
      639,
      646,
      665,
      993,
      994,
      995,
      996,
      997,
      999,
      1000
    ]
  },
  "timeline_lookup": [
    [
      1,
      2737
    ],
    [
      8,
      2736
    ],
    [
      11,
      2735
    ],
    [
      18,
      2734
    ],
    [
      19,
      2722
    ]
  ],
  "tags": [],
  "tags_descriptions": {},
  "fancy_title": "Implementing VersionStamps in bindings",
  "id": 250,
  "title": "Implementing VersionStamps in bindings",
  "posts_count": 25,
  "created_at": "2018-04-24T19:05:11.830Z",
  "views": 5417,
  "reply_count": 18,
  "like_count": 3,
  "last_posted_at": "2018-05-09T18:14:10.990Z",
  "visible": true,
  "closed": false,
  "archived": false,
  "has_summary": false,
  "archetype": "regular",
  "slug": "implementing-versionstamps-in-bindings",
  "category_id": 8,
  "word_count": 7526,
  "deleted_at": null,
  "user_id": 53,
  "featured_link": null,
  "pinned_globally": false,
  "pinned_at": null,
  "pinned_until": null,
  "image_url": null,
  "slow_mode_seconds": 0,
  "draft": null,
  "draft_key": "topic_250",
  "draft_sequence": null,
  "unpinned": null,
  "pinned": false,
  "current_post_number": 1,
  "highest_post_number": 25,
  "deleted_by": null,
  "actions_summary": [
    {
      "id": 4,
      "count": 0,
      "hidden": false,
      "can_act": false
    },
    {
      "id": 8,
      "count": 0,
      "hidden": false,
      "can_act": false
    },
    {
      "id": 10,
      "count": 0,
      "hidden": false,
      "can_act": false
    },
    {
      "id": 7,
      "count": 0,
      "hidden": false,
      "can_act": false
    }
  ],
  "chunk_size": 20,
  "bookmarked": false,
  "topic_timer": null,
  "message_bus_last_id": 0,
  "participant_count": 6,
  "show_read_indicator": false,
  "thumbnails": null,
  "slow_mode_enabled_until": null,
  "tags_disable_ads": false,
  "related_topics": null,
  "summarizable": false,
  "can_vote": false,
  "vote_count": 0,
  "user_voted": false,
  "discourse_zendesk_plugin_zendesk_id": null,
  "discourse_zendesk_plugin_zendesk_url": "https://your-url.zendesk.com/agent/tickets/",
  "details": {
    "can_edit": false,
    "notification_level": 1,
    "participants": [
      {
        "id": 53,
        "username": "KrzysFR",
        "name": "Christophe Chevalier",
        "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
        "post_count": 12,
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_color": null,
        "flair_bg_color": null,
        "flair_group_id": null,
        "trust_level": 2
      },
      {
        "id": 12,
        "username": "ajbeamon",
        "name": "A.J. Beamon",
        "avatar_template": "/user_avatar/forums.foundationdb.org/ajbeamon/{size}/13_2.png",
        "post_count": 4,
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_color": null,
        "flair_bg_color": null,
        "flair_group_id": null,
        "admin": true,
        "trust_level": 4
      },
      {
        "id": 8,
        "username": "alloc",
        "name": "Alec Grieser",
        "avatar_template": "/user_avatar/forums.foundationdb.org/alloc/{size}/9_2.png",
        "post_count": 4,
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_color": null,
        "flair_bg_color": null,
        "flair_group_id": null,
        "trust_level": 4
      },
      {
        "id": 22,
        "username": "dave",
        "name": "David Scherer",
        "avatar_template": "/user_avatar/forums.foundationdb.org/dave/{size}/89_2.png",
        "post_count": 3,
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_color": null,
        "flair_bg_color": null,
        "flair_group_id": null,
        "trust_level": 1
      },
      {
        "id": 156,
        "username": "spullara",
        "name": "Sam Pullara",
        "avatar_template": "/user_avatar/forums.foundationdb.org/spullara/{size}/125_2.png",
        "post_count": 1,
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_color": null,
        "flair_bg_color": null,
        "flair_group_id": null,
        "trust_level": 2
      },
      {
        "id": 120,
        "username": "josephg",
        "name": "Seph Gentle",
        "avatar_template": "/user_avatar/forums.foundationdb.org/josephg/{size}/84_2.png",
        "post_count": 1,
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_color": null,
        "flair_bg_color": null,
        "flair_group_id": null,
        "trust_level": 2
      }
    ],
    "created_by": {
      "id": 53,
      "username": "KrzysFR",
      "name": "Christophe Chevalier",
      "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png"
    },
    "last_poster": {
      "id": 8,
      "username": "alloc",
      "name": "Alec Grieser",
      "avatar_template": "/user_avatar/forums.foundationdb.org/alloc/{size}/9_2.png"
    },
    "links": [
      {
        "url": "https://github.com/apple/foundationdb/blob/f3093642b3c1babe93aacbaee8f60b4008662d52/bindings/java/src/main/com/apple/foundationdb/tuple/TupleUtil.java#L583",
        "title": "foundationdb/TupleUtil.java at f3093642b3c1babe93aacbaee8f60b4008662d52 \u00b7 apple/foundationdb \u00b7 GitHub",
        "internal": false,
        "attachment": false,
        "reflection": false,
        "clicks": 6,
        "user_id": 8,
        "domain": "github.com",
        "root_domain": "github.com"
      },
      {
        "url": "https://github.com/apple/foundationdb/pull/242",
        "title": null,
        "internal": false,
        "attachment": false,
        "reflection": false,
        "clicks": 3,
        "user_id": 53,
        "domain": "github.com",
        "root_domain": "github.com"
      },
      {
        "url": "https://github.com/Doxense/foundationdb-dotnet-client/pull/72",
        "title": "Add support for VersionStamps by KrzysFR \u00b7 Pull Request #72 \u00b7 Doxense/foundationdb-dotnet-client \u00b7 GitHub",
        "internal": false,
        "attachment": false,
        "reflection": false,
        "clicks": 3,
        "user_id": 53,
        "domain": "github.com",
        "root_domain": "github.com"
      },
      {
        "url": "https://github.com/apple/foundationdb/issues/148",
        "title": "Update versionstamp mutation types to make them consistent \u00b7 Issue #148 \u00b7 apple/foundationdb \u00b7 GitHub",
        "internal": false,
        "attachment": false,
        "reflection": false,
        "clicks": 1,
        "user_id": 53,
        "domain": "github.com",
        "root_domain": "github.com"
      },
      {
        "url": "https://forums.foundationdb.org/t/unable-to-use-conflicting-keys-special-keyspace-with-go-bindings/3097",
        "title": "Unable to use conflicting keys special keyspace with Go bindings",
        "internal": true,
        "attachment": false,
        "reflection": true,
        "clicks": 1,
        "user_id": 810,
        "domain": "forums.foundationdb.org",
        "root_domain": "foundationdb.org"
      },
      {
        "url": "https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html",
        "title": "RFC1341(MIME) : 7 The Multipart content type",
        "internal": false,
        "attachment": false,
        "reflection": false,
        "clicks": 1,
        "user_id": 53,
        "domain": "www.w3.org",
        "root_domain": "w3.org"
      },
      {
        "url": "https://forums.foundationdb.org/t/versionstamp-vs-committedversion/600",
        "title": "VersionStamp vs CommittedVersion",
        "internal": true,
        "attachment": false,
        "reflection": true,
        "clicks": 1,
        "user_id": 166,
        "domain": "forums.foundationdb.org",
        "root_domain": "foundationdb.org"
      },
      {
        "url": "https://github.com/apple/foundationdb/blob/master/documentation/sphinx/source/old-release-notes/release-notes-400.rst",
        "title": "foundationdb/release-notes-400.rst at master \u00b7 apple/foundationdb \u00b7 GitHub",
        "internal": false,
        "attachment": false,
        "reflection": false,
        "clicks": 1,
        "user_id": 53,
        "domain": "github.com",
        "root_domain": "github.com"
      }
    ]
  },
  "bookmarks": []
}