{
  "post_stream": {
    "posts": [
      {
        "id": 6039,
        "name": "Vibhuti Dembi",
        "username": "VibhutiD",
        "avatar_template": "/user_avatar/forums.foundationdb.org/vibhutid/{size}/668_2.png",
        "created_at": "2020-01-27T13:38:56.076Z",
        "cooked": "<p>Hi,</p>\n<p>I am facing a certain error while doing a reverse scan namely \u201cjava.lang.NullPointerException: Number types in Tuples may not be null\u201d.<br>\nRepro :</p>\n<pre><code>message order { int64 order_id = 1; int32 price = 2:}\nmessage differentOrder { int64 order_id = 1;}\n</code></pre>\n<p>The primary keys for Order is \u201cconcat(order_id, price)\u201d and for differentOrder is \u201corder_id\u201d. Let\u2019s assume the data I\u2019m migrating is:<br>\nOrder: order_id = 100, price = 0 ; order_id = 100, price = 1.<br>\nDifferentOrder: order_id = 100.<br>\nSince record layer handles 0 as null, the way it is getting stored in FDB (lexicographic order) is:</p>\n<pre><code>&lt;100 encoded&gt;\\x00\\x14    // translates to order Record Type | order_id = 100, price = 0\n100\\x14                              // translates to diffferentOrder Record Type | order_id = 100\n100\\x01\\x14                       // translates to order Record Type | order_id = 100, price = 1\n</code></pre>\n<p>When I do a reverse scan (or even a reverse Sort) on this data, it throws me the error the moment it comes across differentOrder entry. Am I missing out on something here, because it works fine for a forward scan? If not, is this behavior expected?</p>\n<p>Thanks.</p>",
        "post_number": 1,
        "post_type": 1,
        "posts_count": 4,
        "updated_at": "2020-01-27T13:40:24.928Z",
        "reply_count": 0,
        "reply_to_post_number": null,
        "quote_count": 0,
        "incoming_link_count": 73,
        "reads": 34,
        "readers_count": 33,
        "score": 373.8,
        "yours": false,
        "topic_id": 1912,
        "topic_slug": "number-types-in-tuples-may-not-be-null-reverse-scan",
        "display_username": "Vibhuti Dembi",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 653,
        "hidden": false,
        "trust_level": 1,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/number-types-in-tuples-may-not-be-null-reverse-scan/1912/1",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null,
        "can_vote": false
      },
      {
        "id": 6127,
        "name": "Alec Grieser",
        "username": "alloc",
        "avatar_template": "/user_avatar/forums.foundationdb.org/alloc/{size}/9_2.png",
        "created_at": "2020-02-05T07:52:47.233Z",
        "cooked": "<p>Sorry for not getting to this earlier; it had somehow escaped my attention. I think I know what\u2019s going on here, but it\u2019s somewhat subtle, and relates to how the Record Layer stores records at kind of a low-level.</p>\n<p><strong>tl;dr</strong> the Record Layer does not support having two records where the primary key of one is a prefix of the other\u2019s. I thought there was an Issue about this on GitHub, but I couldn\u2019t find it. At the very least, there was at one point somewhere on the agenda something about adding a check to the meta-data validator to ensure that primary keys were always prefix free, but that might not have been moved to the current issue-tracking system.</p>\n<hr>\n<p>So, essentially, when the Record Layer serializes a record to disk, it splits the serialized record across multiple key/value pairs, with each value having at most 100 kB in it, as FDB allows for at most 100 kB per value. To do this, it writes keys that look like (ignoring some prefix bytes that are common for all records in the store):</p>\n<pre><code class=\"lang-auto\">record.primaryKey() + (split_index,) -&gt; some_serialized_bytes\n</code></pre>\n<p>So, if you have a record with a primary key of <code>(100, 1)</code> (like the second <code>order</code> record in your example) and it is 250 kB in size, you will store the first 100 kB in a key ending in <code>(100, 1, 1)</code> (packed as a tuple), the next 100 kB will be in a key ending in <code>(100, 1, 2)</code>, and the final 50 kB will be in a key ending in <code>(100, 1, 3)</code>.</p>\n<p>However, there are two special split indexes: a split index of 0 indicates that the record is \u201cunspilt\u201d (i.e., does not exceed 100 kB in size so fits in a single key) and a split index of -1 is used to store the record\u2019s \u201cversion\u201d (if the feature is enabled) (see: <a href=\"https://foundationdb.github.io/fdb-record-layer/Overview.html#indexing-by-version\">Overview: Indexing by Version</a>). Note that there are good technical reasons for why the version is not stored within the record itself (that I could go into if desired), but that isn\u2019t super relevant to this discussion.</p>\n<p>So, taking your example and using tuples instead of bytes (as <code>\\x14</code> is zero, tuple encoded), we have:</p>\n<pre><code class=\"lang-auto\">(100, null, 0) -&gt; order record 1 (as bytes)\n(100, 0) -&gt; different order record (as bytes)\n(100, 1, 0) -&gt; order record 2 (as bytes)\n</code></pre>\n<p>When a forward scan is performed, the first key we read is <code>(100, null, 0)</code>. From this key, we can deduce that (1) the primary key of the record is <code>(100, null)</code> (just by chopping off the trailing split index of 0) and (2) that the record is not split (because the split index is 0). This means there is no more data to read for that record, so the record is deserialized (huzzah!) and returned to the user.</p>\n<p>The next key is <code>(100, 0)</code>, and from that we conclude that the primary key is <code>(100,)</code> and that we can deserialize and return the second record, and then this again happens for the final record.</p>\n<p>Now, when we scan in reverse, the following happens: the first key read is <code>(100, 1, 0)</code>. This means that the primary key must be <code>(100, 1)</code>, BUT the scan doesn\u2019t know (yet) that this is the only key for that record even though it has a split index of 0, and that\u2019s because there might be a version associated with that record stored at key <code>(100, 1, -1)</code>. So it scans another key, which is <code>(100, 0)</code>. Because this key doesn\u2019t begin with <code>(100, 1)</code> ( the primary key for the record), it must be the key for another record. At this point the scanner knows it has all of the data for record with primary key <code>(100, 1)</code>, so it can deserialize it and return it to the user.</p>\n<p>Now, the reverse scanner at this point knows it has scanned <code>(100, 0)</code>, and from that, it can conclude that this key must be associated with a record with primary key <code>(100,)</code>, and (again) that the record is not split. However, yet again, it doesn\u2019t know that this is the last key for the record, as there might be a version for the record stored at key <code>(100, -1)</code>. So, it reads another key. This time, it sees that the key, which is <code>(100, null, 0)</code> <em>does</em> begin with <code>(100,)</code>, so it think that that key contains more information about the record with primary key <code>(100,)</code>, so it tries to inspect the split index. But this time the split index is <code>null</code> (ah!) and an NPE results.</p>\n<p>But note that though we got a null pointer exception in this case, the results could be worse. For example, suppose you had a split record with primary key <code>(100,)</code>, so you write to keys <code>(100, 1)</code> and <code>(100, 2)</code>. But then if you have an unsplit record with primary key <code>(100, 1)</code> that you then write to key <code>(100, 1, 0)</code>. Well, <code>(100, 1)</code> &lt; <code>(100, 1, 0)</code> &lt; <code>(100, 2)</code>, so the record will be written <em>in between</em> the data for the other record. Yikes!</p>\n<p>As for solutions, you could:</p>\n<ol>\n<li>Ensure all primary keys of all types have the same number of columns (e.g., the same number of fields in the key expression). The problem only arises when one record\u2019s primary key is the strict prefix of another (and can therefore have its data intermingled with another type\u2019s data). However, you can still have two records with the exact same primary key (and different types), but they will cause problems in a different way (namely, one can overwrite the value of the other).</li>\n<li>Prefix all primary keys of all records with the <code>recordType()</code> key expression. (See: <a href=\"https://foundationdb.github.io/fdb-record-layer/FAQ.html#are-record-types-tables\">FAQ: Are record types tables?</a> and <a href=\"https://javadoc.io/static/org.foundationdb/fdb-record-layer-core/2.8.98.0/com/apple/foundationdb/record/metadata/Key.Expressions.html#recordType--\">Key.Expressions.recordType()</a>) This will put a value at the beginning of the primary key that is unique for each record type, and this ensures that no two records have primary keys where one is a strict prefix of a another as (1) if the records are of different types, then the first column is different and (2) if the records are the same type, then they must have the same number of columns (a property of key expressions). This has other benefits, too, as it allows the record layer to make some optimizations because it knows records of the same type are grouped together.</li>\n<li>Come up with your own plan to avoid prefix collisions.</li>\n</ol>\n<p>As for whether the Record Layer should handle this on its own, I think there are a couple different approaches:</p>\n<ol>\n<li>Throwing an error when validating the meta-data if either (1) the primary keys do not have the same number of columns and (2) are not prefixed by the type key. (Essentially mandating either (1) or (2) above.) If you ignore <code>null</code> values (which could be safe if the field is guaranteed non-null), you can do additional validation based on the types of the values in the key expression.</li>\n<li>Adding more checks at the time of writing a record. The problem here though is that while it is straightforward to check to make sure that the given record is not a prefix of any other record (by scanning for keys with the prefix\u2013a check it has to do anyway to know if there is a record already present at that key that it is then going to replace), scanning for other records that might be a prefix of it is less so. (It would, at the least, make writing every record more expensive.)</li>\n<li>Changing the on disk format (gasp!) in a way that doesn\u2019t have this limitation, though this would require some thought as to how it is rolled out. In particular (and I understand I\u2019ve already rambled on a bunch and this is getting fairly deep into the gritty details here), the FDB tuple layer supports nested tuples, and I think that if instead of encoding primary keys with their split points as <code>primaryKey() + (split_index,)</code> (i.e., concatenating two tuples where the last entry is the split index and rest are the primary key) it was encoded as <code>(primaryKey(), split_index)</code> (i.e., a 2-tuple with the first entry being the (nested) primary key tuple and the second entry being the split index), then I think\u2026everything just works? The entries now really would be grouped by primary key and if one primary key was a prefix of another, the way we encode nested primary keys would ensure every single entry of the shorter key was before every single entry of the second, and you could always tell (when doing a scan) when the scan \u201cswitches\u201d from one primary key to another.</li>\n</ol>\n<p>I do kind of like the third approach on a philosophical level, but it is also incompatible with the current way data are serialized to disk, so we would need to do something to avoid, like, accidentally making all data unreadable on all existing record stores.</p>",
        "post_number": 2,
        "post_type": 1,
        "posts_count": 4,
        "updated_at": "2020-02-05T07:52:47.233Z",
        "reply_count": 1,
        "reply_to_post_number": null,
        "quote_count": 0,
        "incoming_link_count": 4,
        "reads": 36,
        "readers_count": 35,
        "score": 32.2,
        "yours": false,
        "topic_id": 1912,
        "topic_slug": "number-types-in-tuples-may-not-be-null-reverse-scan",
        "display_username": "Alec Grieser",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "link_counts": [
          {
            "url": "https://javadoc.io/static/org.foundationdb/fdb-record-layer-core/2.8.98.0/com/apple/foundationdb/record/metadata/Key.Expressions.html#recordType--",
            "internal": false,
            "reflection": false,
            "title": "Key.Expressions (fdb-record-layer-core 2.8.98.0 API)",
            "clicks": 1
          },
          {
            "url": "https://foundationdb.github.io/fdb-record-layer/Overview.html#indexing-by-version",
            "internal": false,
            "reflection": false,
            "title": "FoundationDB Record Layer Overview",
            "clicks": 0
          },
          {
            "url": "https://foundationdb.github.io/fdb-record-layer/FAQ.html#are-record-types-tables",
            "internal": false,
            "reflection": false,
            "title": "FoundationDB Record Layer FAQ",
            "clicks": 0
          }
        ],
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 8,
        "hidden": false,
        "trust_level": 4,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/number-types-in-tuples-may-not-be-null-reverse-scan/1912/2",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 6264,
        "name": "Vibhuti Dembi",
        "username": "VibhutiD",
        "avatar_template": "/user_avatar/forums.foundationdb.org/vibhutid/{size}/668_2.png",
        "created_at": "2020-02-19T12:10:44.174Z",
        "cooked": "<p>Hi Alec,</p>\n<p>Thanks for helping out. I have a follow up question w.r.t one of the approaches that you suggested, though it is unrelated to the topic mentioned.</p>\n<aside class=\"quote no-group\" data-username=\"alloc\" data-post=\"2\" data-topic=\"1912\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/alloc/48/9_2.png\" class=\"avatar\"> alloc:</div>\n<blockquote>\n<p>Prefix all primary keys of all records with the <code>recordType()</code> key expression.</p>\n</blockquote>\n</aside>\n<p>Prefixing all the primary keys of all the records with the recordType() key expression solves the said problem (and <a href=\"https://github.com/FoundationDB/fdb-record-layer/issues/765\" rel=\"noopener nofollow ugc\">others</a>) but I have a doubt w.r.t the behavior of the following Query:</p>\n<p>Let\u2019s assume that I want to get the entries of order where order_id &lt; 50,000 and I want to do a reverse sort on concat(recordtype/order_id/price). According to the planner behavior of \u201c.setSort()\u201d, <em><strong>if the sort matches an index that can satisfy a filter, then the index is used</strong></em>. I am unable to replicate this behavior for the following query.</p>\n<p>Query :<br>\n<code>RecordQuery.newBuilder()  .setFilter(Query.and(Query.field(\"order_id\").lessThan(50000L), Query.field(\"price\").equalsValue(4)) .setSort(concat(key.Expressions.recordType(), key.Expressions.field(\"order_id\"), key.Expressions.field(\"price\")) .build()</code></p>\n<p>My understanding of why the planner is not able to take the filter that satisfies the index ( or primary key) is that the QueryComponent created does not contain the recordType \u201cfield\u201d and hence sort does not match the filter index.Is my understanding correct?<br>\nI tried to set a filter Query.keyExpression(Key.Expressions.recordType()) but it throws an Exception \u201cquery key expression must be queryable\u201d. ( which makes sense )</p>\n<p>I essentially want the data-set of the reverse sort to be filtered/reduced. ( I have additional filters on top of this subset of data) Is there a way to do this that I am missing out on? (That does not involve creating a separate index on \u201corder_id\u201d )</p>\n<p>Thanks.</p>",
        "post_number": 3,
        "post_type": 1,
        "posts_count": 4,
        "updated_at": "2020-02-19T12:10:44.174Z",
        "reply_count": 1,
        "reply_to_post_number": 2,
        "quote_count": 1,
        "incoming_link_count": 2,
        "reads": 28,
        "readers_count": 27,
        "score": 15.6,
        "yours": false,
        "topic_id": 1912,
        "topic_slug": "number-types-in-tuples-may-not-be-null-reverse-scan",
        "display_username": "Vibhuti Dembi",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "link_counts": [
          {
            "url": "https://github.com/FoundationDB/fdb-record-layer/issues/765",
            "internal": false,
            "reflection": false,
            "title": "Inequality comparisons are not coalesced on single field indexes \u00b7 Issue #765 \u00b7 FoundationDB/fdb-record-layer \u00b7 GitHub",
            "clicks": 1
          }
        ],
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 653,
        "hidden": false,
        "trust_level": 1,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/number-types-in-tuples-may-not-be-null-reverse-scan/1912/3",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 6278,
        "name": "Alec Grieser",
        "username": "alloc",
        "avatar_template": "/user_avatar/forums.foundationdb.org/alloc/{size}/9_2.png",
        "created_at": "2020-02-20T14:50:37.088Z",
        "cooked": "<p>Though I haven\u2019t looked into it too deeply, this kind of looks like <a href=\"https://github.com/FoundationDB/fdb-record-layer/issues/744\">https://github.com/FoundationDB/fdb-record-layer/issues/744</a> to me (i.e., a known bug/deficiency).</p>\n<p>As to why the query planner can\u2019t use the index in <span class=\"hashtag\">#744</span> (and probably your example), I think it has less to do with whether the query component has the record type as much as just that the logic in the planner (which is trying to match the sort first and then the filter on the indexes) just isn\u2019t quite sophisticated enough. There\u2019s already some special handling of the record type information, though it could be added to more places.</p>\n<p>The error message about queryability is essentially just saying that it needs to be a key expression that implements <code>QueryableKeyExpression</code>. That is used I think by our <code>FunctionKeyExpressions</code> or something like that.</p>\n<p>What is the index you\u2019ve defined? And is it defined on just a single type? If it\u2019s a single type index, you can remove the record type field from your sort entirely. If it\u2019s a multi-type index that\u2019s \u201cgrouped\u201d by record type, then that\u2019s kind of the only query you can issue. You could also, if you want, issue a scan of the index yourself (with one of the <code>.scanIndex</code> methods on <code>FDBRecordStore</code>), and bypass the planner.</p>\n<p>It seems like your aware of the tradeoffs, but just for any onlookers, it does look like this will do a full scan of the entire index (if it is \u201cget me all records of all types sorted by type then order ID then price, then filter out the indexes with the wrong prices and order IDs\u201d). That\u2019s fine if this is like an offline analytics query or something. It might cause problems if this query needs to be fast (in which case a separate, multi-type index on order_id might be required).</p>",
        "post_number": 4,
        "post_type": 1,
        "posts_count": 4,
        "updated_at": "2020-02-20T14:50:37.088Z",
        "reply_count": 0,
        "reply_to_post_number": 3,
        "quote_count": 0,
        "incoming_link_count": 5,
        "reads": 23,
        "readers_count": 22,
        "score": 29.6,
        "yours": false,
        "topic_id": 1912,
        "topic_slug": "number-types-in-tuples-may-not-be-null-reverse-scan",
        "display_username": "Alec Grieser",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "link_counts": [
          {
            "url": "https://github.com/FoundationDB/fdb-record-layer/issues/744",
            "internal": false,
            "reflection": false,
            "clicks": 5
          }
        ],
        "read": true,
        "user_title": null,
        "reply_to_user": {
          "id": 653,
          "username": "VibhutiD",
          "name": "Vibhuti Dembi",
          "avatar_template": "/user_avatar/forums.foundationdb.org/vibhutid/{size}/668_2.png"
        },
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 8,
        "hidden": false,
        "trust_level": 4,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/number-types-in-tuples-may-not-be-null-reverse-scan/1912/4",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      }
    ],
    "stream": [
      6039,
      6127,
      6264,
      6278
    ]
  },
  "timeline_lookup": [
    [
      1,
      2094
    ],
    [
      2,
      2086
    ],
    [
      3,
      2071
    ],
    [
      4,
      2070
    ]
  ],
  "suggested_topics": [],
  "tags": [],
  "tags_descriptions": {},
  "fancy_title": "Number types in Tuples may not be null | Reverse scan",
  "id": 1912,
  "title": "Number types in Tuples may not be null | Reverse scan",
  "posts_count": 4,
  "created_at": "2020-01-27T13:38:56.010Z",
  "views": 992,
  "reply_count": 2,
  "like_count": 0,
  "last_posted_at": "2020-02-20T14:50:37.088Z",
  "visible": true,
  "closed": false,
  "archived": false,
  "has_summary": false,
  "archetype": "regular",
  "slug": "number-types-in-tuples-may-not-be-null-reverse-scan",
  "category_id": 12,
  "word_count": 2364,
  "deleted_at": null,
  "user_id": 653,
  "featured_link": null,
  "pinned_globally": false,
  "pinned_at": null,
  "pinned_until": null,
  "image_url": null,
  "slow_mode_seconds": 0,
  "draft": null,
  "draft_key": "topic_1912",
  "draft_sequence": null,
  "unpinned": null,
  "pinned": false,
  "current_post_number": 1,
  "highest_post_number": 4,
  "deleted_by": null,
  "actions_summary": [
    {
      "id": 4,
      "count": 0,
      "hidden": false,
      "can_act": false
    },
    {
      "id": 8,
      "count": 0,
      "hidden": false,
      "can_act": false
    },
    {
      "id": 10,
      "count": 0,
      "hidden": false,
      "can_act": false
    },
    {
      "id": 7,
      "count": 0,
      "hidden": false,
      "can_act": false
    }
  ],
  "chunk_size": 20,
  "bookmarked": false,
  "topic_timer": null,
  "message_bus_last_id": 0,
  "participant_count": 2,
  "show_read_indicator": false,
  "thumbnails": null,
  "slow_mode_enabled_until": null,
  "tags_disable_ads": false,
  "related_topics": [
    {
      "fancy_title": "Full range scan performed in sort when not required",
      "id": 1995,
      "title": "Full range scan performed in sort when not required",
      "slug": "full-range-scan-performed-in-sort-when-not-required",
      "posts_count": 4,
      "reply_count": 2,
      "highest_post_number": 4,
      "image_url": null,
      "created_at": "2020-03-02T10:49:06.926Z",
      "last_posted_at": "2020-03-03T10:16:53.281Z",
      "bumped": true,
      "bumped_at": "2020-03-03T10:16:53.281Z",
      "archetype": "regular",
      "unseen": false,
      "pinned": false,
      "unpinned": null,
      "visible": true,
      "closed": false,
      "archived": false,
      "bookmarked": null,
      "liked": null,
      "tags": [],
      "tags_descriptions": {},
      "like_count": 1,
      "views": 987,
      "category_id": 12,
      "featured_link": null,
      "has_accepted_answer": false,
      "posters": [
        {
          "extras": "latest",
          "description": "Original Poster, Most Recent Poster",
          "user": {
            "id": 737,
            "username": "aymalik",
            "name": "Aayushi Malik",
            "avatar_template": "https://avatars.discourse-cdn.com/v4/letter/a/aca169/{size}.png",
            "trust_level": 1
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 8,
            "username": "alloc",
            "name": "Alec Grieser",
            "avatar_template": "/user_avatar/forums.foundationdb.org/alloc/{size}/9_2.png",
            "trust_level": 4
          }
        }
      ]
    },
    {
      "fancy_title": "Split long record causes conflict with other record",
      "id": 2160,
      "title": "Split long record causes conflict with other record",
      "slug": "split-long-record-causes-conflict-with-other-record",
      "posts_count": 4,
      "reply_count": 2,
      "highest_post_number": 4,
      "image_url": null,
      "created_at": "2020-06-04T05:04:39.122Z",
      "last_posted_at": "2020-06-10T18:04:42.683Z",
      "bumped": true,
      "bumped_at": "2020-06-10T18:04:42.683Z",
      "archetype": "regular",
      "unseen": false,
      "pinned": false,
      "unpinned": null,
      "visible": true,
      "closed": false,
      "archived": false,
      "bookmarked": null,
      "liked": null,
      "tags": [],
      "tags_descriptions": {},
      "like_count": 3,
      "views": 932,
      "category_id": 12,
      "featured_link": null,
      "has_accepted_answer": false,
      "posters": [
        {
          "extras": null,
          "description": "Original Poster",
          "user": {
            "id": 775,
            "username": "iamquang95",
            "name": "Quang Le Hong",
            "avatar_template": "/user_avatar/forums.foundationdb.org/iamquang95/{size}/889_2.png",
            "trust_level": 1
          }
        },
        {
          "extras": "latest",
          "description": "Most Recent Poster",
          "user": {
            "id": 8,
            "username": "alloc",
            "name": "Alec Grieser",
            "avatar_template": "/user_avatar/forums.foundationdb.org/alloc/{size}/9_2.png",
            "trust_level": 4
          }
        }
      ]
    },
    {
      "fancy_title": "Mixed ascending/descending sort?",
      "id": 1582,
      "title": "Mixed ascending/descending sort?",
      "slug": "mixed-ascending-descending-sort",
      "posts_count": 2,
      "reply_count": 0,
      "highest_post_number": 2,
      "image_url": null,
      "created_at": "2019-08-12T21:35:24.255Z",
      "last_posted_at": "2019-08-12T23:19:20.337Z",
      "bumped": true,
      "bumped_at": "2019-08-12T23:19:20.337Z",
      "archetype": "regular",
      "unseen": false,
      "pinned": false,
      "unpinned": null,
      "visible": true,
      "closed": false,
      "archived": false,
      "bookmarked": null,
      "liked": null,
      "tags": [],
      "tags_descriptions": {},
      "like_count": 0,
      "views": 1070,
      "category_id": 12,
      "featured_link": null,
      "has_accepted_answer": false,
      "posters": [
        {
          "extras": null,
          "description": "Original Poster",
          "user": {
            "id": 173,
            "username": "jkominek",
            "name": "Jay Kominek",
            "avatar_template": "/user_avatar/forums.foundationdb.org/jkominek/{size}/140_2.png",
            "trust_level": 2
          }
        },
        {
          "extras": "latest",
          "description": "Most Recent Poster",
          "user": {
            "id": 8,
            "username": "alloc",
            "name": "Alec Grieser",
            "avatar_template": "/user_avatar/forums.foundationdb.org/alloc/{size}/9_2.png",
            "trust_level": 4
          }
        }
      ]
    },
    {
      "fancy_title": "Application design using Subspace and Tuple",
      "id": 452,
      "title": "Application design using Subspace and Tuple",
      "slug": "application-design-using-subspace-and-tuple",
      "posts_count": 9,
      "reply_count": 7,
      "highest_post_number": 9,
      "image_url": null,
      "created_at": "2018-05-22T21:46:43.537Z",
      "last_posted_at": "2018-07-14T21:02:50.010Z",
      "bumped": true,
      "bumped_at": "2018-07-14T21:02:50.010Z",
      "archetype": "regular",
      "unseen": false,
      "pinned": false,
      "unpinned": null,
      "visible": true,
      "closed": false,
      "archived": false,
      "bookmarked": null,
      "liked": null,
      "tags": [],
      "tags_descriptions": {},
      "like_count": 5,
      "views": 3678,
      "category_id": 7,
      "featured_link": null,
      "has_accepted_answer": false,
      "posters": [
        {
          "extras": null,
          "description": "Original Poster",
          "user": {
            "id": 211,
            "username": "brk0v",
            "name": "Viacheslav Biriukov",
            "avatar_template": "/user_avatar/forums.foundationdb.org/brk0v/{size}/173_2.png",
            "trust_level": 1
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 53,
            "username": "KrzysFR",
            "name": "Christophe Chevalier",
            "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
            "trust_level": 2
          }
        },
        {
          "extras": "latest",
          "description": "Most Recent Poster",
          "user": {
            "id": 317,
            "username": "Lundin",
            "name": "Pontus Lundin",
            "avatar_template": "https://avatars.discourse-cdn.com/v4/letter/l/dfb087/{size}.png",
            "trust_level": 1
          }
        }
      ]
    },
    {
      "fancy_title": "Range scan not being truncated by primary key filter when an additional Or component present in And component",
      "id": 1996,
      "title": "Range scan not being truncated by primary key filter when an additional Or component present in And component",
      "slug": "range-scan-not-being-truncated-by-primary-key-filter-when-an-additional-or-component-present-in-and-component",
      "posts_count": 3,
      "reply_count": 1,
      "highest_post_number": 3,
      "image_url": null,
      "created_at": "2020-03-02T12:25:09.669Z",
      "last_posted_at": "2020-03-03T10:11:33.746Z",
      "bumped": true,
      "bumped_at": "2020-03-03T10:11:33.746Z",
      "archetype": "regular",
      "unseen": false,
      "pinned": false,
      "unpinned": null,
      "visible": true,
      "closed": false,
      "archived": false,
      "bookmarked": null,
      "liked": null,
      "tags": [],
      "tags_descriptions": {},
      "like_count": 0,
      "views": 640,
      "category_id": 12,
      "featured_link": null,
      "has_accepted_answer": false,
      "posters": [
        {
          "extras": "latest",
          "description": "Original Poster, Most Recent Poster",
          "user": {
            "id": 737,
            "username": "aymalik",
            "name": "Aayushi Malik",
            "avatar_template": "https://avatars.discourse-cdn.com/v4/letter/a/aca169/{size}.png",
            "trust_level": 1
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 8,
            "username": "alloc",
            "name": "Alec Grieser",
            "avatar_template": "/user_avatar/forums.foundationdb.org/alloc/{size}/9_2.png",
            "trust_level": 4
          }
        }
      ]
    }
  ],
  "summarizable": false,
  "can_vote": false,
  "vote_count": 0,
  "user_voted": false,
  "discourse_zendesk_plugin_zendesk_id": null,
  "discourse_zendesk_plugin_zendesk_url": "https://your-url.zendesk.com/agent/tickets/",
  "details": {
    "can_edit": false,
    "notification_level": 1,
    "participants": [
      {
        "id": 8,
        "username": "alloc",
        "name": "Alec Grieser",
        "avatar_template": "/user_avatar/forums.foundationdb.org/alloc/{size}/9_2.png",
        "post_count": 2,
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_color": null,
        "flair_bg_color": null,
        "flair_group_id": null,
        "trust_level": 4
      },
      {
        "id": 653,
        "username": "VibhutiD",
        "name": "Vibhuti Dembi",
        "avatar_template": "/user_avatar/forums.foundationdb.org/vibhutid/{size}/668_2.png",
        "post_count": 2,
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_color": null,
        "flair_bg_color": null,
        "flair_group_id": null,
        "trust_level": 1
      }
    ],
    "created_by": {
      "id": 653,
      "username": "VibhutiD",
      "name": "Vibhuti Dembi",
      "avatar_template": "/user_avatar/forums.foundationdb.org/vibhutid/{size}/668_2.png"
    },
    "last_poster": {
      "id": 8,
      "username": "alloc",
      "name": "Alec Grieser",
      "avatar_template": "/user_avatar/forums.foundationdb.org/alloc/{size}/9_2.png"
    },
    "links": [
      {
        "url": "https://github.com/FoundationDB/fdb-record-layer/issues/744",
        "title": null,
        "internal": false,
        "attachment": false,
        "reflection": false,
        "clicks": 5,
        "user_id": 8,
        "domain": "github.com",
        "root_domain": "github.com"
      },
      {
        "url": "https://github.com/FoundationDB/fdb-record-layer/issues/765",
        "title": "Inequality comparisons are not coalesced on single field indexes \u00b7 Issue #765 \u00b7 FoundationDB/fdb-record-layer \u00b7 GitHub",
        "internal": false,
        "attachment": false,
        "reflection": false,
        "clicks": 1,
        "user_id": 653,
        "domain": "github.com",
        "root_domain": "github.com"
      },
      {
        "url": "https://javadoc.io/static/org.foundationdb/fdb-record-layer-core/2.8.98.0/com/apple/foundationdb/record/metadata/Key.Expressions.html#recordType--",
        "title": "Key.Expressions (fdb-record-layer-core 2.8.98.0 API)",
        "internal": false,
        "attachment": false,
        "reflection": false,
        "clicks": 1,
        "user_id": 8,
        "domain": "javadoc.io",
        "root_domain": "javadoc.io"
      }
    ]
  },
  "bookmarks": []
}