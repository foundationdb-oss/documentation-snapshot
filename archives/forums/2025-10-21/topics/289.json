{
  "post_stream": {
    "posts": [
      {
        "id": 649,
        "name": "David Scherer",
        "username": "dave",
        "avatar_template": "/user_avatar/forums.foundationdb.org/dave/{size}/89_2.png",
        "created_at": "2018-04-27T14:04:16.497Z",
        "cooked": "<p>Goal: be able to detect database property failures in simulation very precisely even when running very weird randomized workloads, which might sometimes deliberately weaken serializability or just be nondeterministic in nature.  See for example <a href=\"https://github.com/apple/foundationdb/issues/126\" rel=\"nofollow noopener\">issue 126</a> which I guess must have slipped through a crack in existing workloads?</p>\n<p>The basic idea is that rather than try to determine if an arbitrary result is consistent with <em>some</em> legal behavior of the database, which is a challenging search problem in general, we take advantage of the fact that FoundationDB\u2019s implementation actually <em>constructs</em> a (supposedly) valid serialization order to check a strictly stronger property.</p>\n<p>Start with an arbitrary concurrent workload, running in simulation, and using the API pretty freely (but I guess staying away from system keys and management APIs).  The distribution of behavior, of course, matters and there is plenty of room for creativity.</p>\n<p>Have each simulated workload client keep (out of band, safe from simulated failures, and above the level of the RYW API) a record of all its read and write transactions, including true simulation times before and after, an identifier unique for each transaction (retry) snapshot and (where commit() succeeds) commit versions, and details of reads and writes.  It\u2019s probably OK to store only a hash of the results for reads.</p>\n<p>Augment each transaction with a versionstamped operation (either key or value) that includes the unique identifier.</p>\n<p>After the workload is complete, from looking at the versionstamped operation log we know the final serialization order of all transactions that were attempted by any client: if the transaction was read only, it serializes at (the end of?) the snapshot version.  If it was read/write and does not occur in the operation log it did not occur, and if it does occur it should serialize in just that order.</p>\n<p>Combining this information with the out of band logs from each client, we can check, separately:<br>\n(1) that the serialization order is compatible with the before and after times recorded for each transaction (external consistency), that every transaction that the client saw successfully commit() serialized (durability), and that transactions the client received not_committed() for did <em>not</em> serialize, and<br>\n(2) that every read and the final contents of the database are (isolation, atomicity, many other properties) exactly what would be predicted by executing each operation sequentially in the serialization order (using <code>MemoryKeyValueStore</code>, and perhaps ideally an independent implementation of the atomic mutations as in the specific workload for that?)</p>\n<p>Together these properties should more or less precisely validate the database\u2019s contract.  The only restriction on workloads is that there can\u2019t be a transaction without a versionstamped write but with other writes, but it is hard for me to imagine a realistic bug that can\u2019t manifest with that restriction.</p>\n<p>It would be interesting to implement this technique as a wrapper on the transaction API, so that it could easily be reused by different workloads.</p>\n<p>Thoughts?</p>",
        "post_number": 1,
        "post_type": 1,
        "posts_count": 11,
        "updated_at": "2018-04-27T14:04:16.497Z",
        "reply_count": 0,
        "reply_to_post_number": null,
        "quote_count": 0,
        "incoming_link_count": 77,
        "reads": 74,
        "readers_count": 73,
        "score": 396.8,
        "yours": false,
        "topic_id": 289,
        "topic_slug": "a-precise-test-oracle-for-foundationdb-simulation-workloads",
        "display_username": "David Scherer",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "link_counts": [
          {
            "url": "https://github.com/apple/foundationdb/issues/126",
            "internal": false,
            "reflection": false,
            "title": "Adding an explicit read conflict range skips the keys in write cache \u00b7 Issue #126 \u00b7 apple/foundationdb \u00b7 GitHub",
            "clicks": 35
          }
        ],
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 22,
        "hidden": false,
        "trust_level": 1,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/a-precise-test-oracle-for-foundationdb-simulation-workloads/289/1",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null,
        "can_vote": false
      },
      {
        "id": 659,
        "name": "Evan Tschannen",
        "username": "Evan",
        "avatar_template": "/user_avatar/forums.foundationdb.org/evan/{size}/104_2.png",
        "created_at": "2018-04-27T17:45:18.872Z",
        "cooked": "<p>I really like this test idea Dave.</p>\n<p>To catch issue 126 this would have to be implemented above the read your writes transaction, but that would make it more difficult to validate because we would have to re-implement read your writes at that level. My thoughts would be to have a separate test that would catch that issue, and put this code at the NativeAPI level.</p>",
        "post_number": 2,
        "post_type": 1,
        "posts_count": 11,
        "updated_at": "2018-04-27T17:45:18.872Z",
        "reply_count": 1,
        "reply_to_post_number": null,
        "quote_count": 0,
        "incoming_link_count": 0,
        "reads": 63,
        "readers_count": 62,
        "score": 17.6,
        "yours": false,
        "topic_id": 289,
        "topic_slug": "a-precise-test-oracle-for-foundationdb-simulation-workloads",
        "display_username": "Evan Tschannen",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": true,
        "admin": false,
        "staff": true,
        "user_id": 54,
        "hidden": false,
        "trust_level": 1,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/a-precise-test-oracle-for-foundationdb-simulation-workloads/289/2",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 662,
        "name": "David Scherer",
        "username": "dave",
        "avatar_template": "/user_avatar/forums.foundationdb.org/dave/{size}/89_2.png",
        "created_at": "2018-04-27T19:02:39.924Z",
        "cooked": "<p>I don\u2019t think you need to re-implement read your writes to get it under test.  The whole idea of read your writes is to exactly emulate the behavior of carrying out each operation sequentially.  So you loop over transactions sequentially and then over operations within the transaction sequentially and execute them one at a time to find the correct answer.  I think the serialization order for RYW is supposed to be exactly the issue order.  Right?</p>",
        "post_number": 3,
        "post_type": 1,
        "posts_count": 11,
        "updated_at": "2018-04-27T19:02:39.924Z",
        "reply_count": 0,
        "reply_to_post_number": 2,
        "quote_count": 0,
        "incoming_link_count": 0,
        "reads": 61,
        "readers_count": 60,
        "score": 12.2,
        "yours": false,
        "topic_id": 289,
        "topic_slug": "a-precise-test-oracle-for-foundationdb-simulation-workloads",
        "display_username": "David Scherer",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "reply_to_user": {
          "id": 54,
          "username": "Evan",
          "name": "Evan Tschannen",
          "avatar_template": "/user_avatar/forums.foundationdb.org/evan/{size}/104_2.png"
        },
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 22,
        "hidden": false,
        "trust_level": 1,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/a-precise-test-oracle-for-foundationdb-simulation-workloads/289/3",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 663,
        "name": "Alex Miller",
        "username": "alexmiller",
        "avatar_template": "/user_avatar/forums.foundationdb.org/alexmiller/{size}/326_2.png",
        "created_at": "2018-04-27T19:23:53.775Z",
        "cooked": "<p>For this to catch the class of problems found in <span class=\"hashtag\">#126</span>, I believe one would have to additionally check that all transactions stored with the same versionstamp don\u2019t conflict?  Otherwise we\u2019d still have nothing that covers testing of adding read or write conflicts.</p>\n<p>It\u2019s interesting to note that this would handle replayed commits correctly.</p>",
        "post_number": 4,
        "post_type": 1,
        "posts_count": 11,
        "updated_at": "2018-04-27T19:23:53.775Z",
        "reply_count": 1,
        "reply_to_post_number": null,
        "quote_count": 0,
        "incoming_link_count": 0,
        "reads": 59,
        "readers_count": 58,
        "score": 16.8,
        "yours": false,
        "topic_id": 289,
        "topic_slug": "a-precise-test-oracle-for-foundationdb-simulation-workloads",
        "display_username": "Alex Miller",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 13,
        "hidden": false,
        "trust_level": 4,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/a-precise-test-oracle-for-foundationdb-simulation-workloads/289/4",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 669,
        "name": "David Scherer",
        "username": "dave",
        "avatar_template": "/user_avatar/forums.foundationdb.org/dave/{size}/89_2.png",
        "created_at": "2018-04-27T20:14:07.145Z",
        "cooked": "<p>This is, evidently, a good question, because I\u2019ve flip flopped on whether you are right several times in the course of responding.</p>\n<p>I think that my proposal as written works for <span class=\"hashtag\">#126</span> (as detailed below), but in fact has a closely related <em>soundness</em> bug: it will falsely complain about the behavior of regular snapshot reads in a read/write transaction (since I said that a read/write transaction serializes at its commit versionstamp, and after all snapshot reads are not serializable).  Trying to fix <em>that</em> in the obvious way by treating snapshot reads as taking place in a separate read only transaction at the snapshot version then leads to the problem you are concerned about.</p>\n<p>I would keep looking for a more precise and elegant solution, but maybe it is necessary to look at the read conflict ranges and promote snapshot reads that have a read conflict range to serializable for the purposes of the oracle.  (That still might not be 100% precise for cases involving extra conflict ranges. It\u2019s possible to order two particular transactions through conflict ranges that don\u2019t involve any actual reads or writes, but if we don\u2019t detect this then the oracle wouldn\u2019t promote the reads to serializable and so might not validate that it worked.)</p>\n<p>Another strategy, which I think you allude to, would be to add a third <em>class</em> of check that the serialization order is consistent with the conflict ranges of each transaction.</p>\n<hr>\n<p>If the workload does the exact operations (with the same real-time ordering) that Alec described in issue <span class=\"hashtag\">#126</span>, because of the bug the transactions <code>tr1</code> and <code>tr2</code> do not conflict, and they serialize in order.  Let\u2019s say the read snapshots of both transactions are version 100, the commit version of tr1 is 101 and the commit version of tr2 is 102.</p>\n<p>When the test oracle replayed the operations, it would do so in the serialization order (not the real-time ordering), ignoring versions and conflict ranges entirely (and skipping transactions which have no place in the serialization order, but there are no such in this example).  <em>Because</em> the serialization order generated by the database broke contract, it won\u2019t see the same results:</p>\n<p>(tr1) read(k) -&gt; 1<br>\n(tr1) set(k,2)</p>\n<p>(tr2) read(k) -&gt; 2   (!!! ERROR !!! Got 2, expected 1!)</p>",
        "post_number": 5,
        "post_type": 1,
        "posts_count": 11,
        "updated_at": "2018-04-27T20:14:07.145Z",
        "reply_count": 1,
        "reply_to_post_number": 4,
        "quote_count": 0,
        "incoming_link_count": 1,
        "reads": 60,
        "readers_count": 59,
        "score": 22.0,
        "yours": false,
        "topic_id": 289,
        "topic_slug": "a-precise-test-oracle-for-foundationdb-simulation-workloads",
        "display_username": "David Scherer",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "reply_to_user": {
          "id": 13,
          "username": "alexmiller",
          "name": "Alex Miller",
          "avatar_template": "/user_avatar/forums.foundationdb.org/alexmiller/{size}/326_2.png"
        },
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 22,
        "hidden": false,
        "trust_level": 1,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/a-precise-test-oracle-for-foundationdb-simulation-workloads/289/5",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 671,
        "name": "Alex Miller",
        "username": "alexmiller",
        "avatar_template": "/user_avatar/forums.foundationdb.org/alexmiller/{size}/326_2.png",
        "created_at": "2018-04-27T23:08:54.251Z",
        "cooked": "<p>Ah, yes, I agree that your proposal would cover <span class=\"hashtag\">#126</span>, as the specific bug dealt with operations that overlapped with added conflict ranges, and that it covers checking if the serializable schedule recorded on the tlogs is actually a correct schedule for the operations performed.  And in the ~5min our team had previously spent discussing your comment on <span class=\"hashtag\">#126</span>, we agreed that it\u2019s a thing that would be good to have a test over.</p>\n<p>I had interpreted <span class=\"hashtag\">#126</span> as general commentary that we lack testing over manually added conflict ranges.  To illustrate the pathological case, I could create a workload that performs operations, and whose only conflicts come from manually added conflict ranges.  Any ordering of these transactions would be valid according to their reads and writes, but just checking the serializable schedule against the operations wouldn\u2019t validate that the serializable schedule was a correctly accepted transaction schedule.  I\u2019m unsure if there\u2019s any way to solve this without the oracle checking conflict ranges as well.</p>\n<p>And, as long as I\u2019m being pedantic, doing validation without checking conflict ranges means that we\u2019d be asserting that the produced schedule is view-serializable and not conflict-serializable, the latter of which is stricter and what FDB claims to produce.  This would leave a gap in coverage, where the resolvers could incorrectly accept view-serializable schedules.  However, them doing so would, essentially by definition, not be observable by the client (unless they stare very very closely at the transaction schedule).  If there was a way FDB could be view-serializable, I\u2019d fully support it, so this doesn\u2019t actually bother me at all.</p>\n<p>Your outlined oracle approach follows what I\u2019ve previously seen of validating strictly serializable systems\u2019 transaction schedules, so it seems like a good overall approach to me.</p>\n<hr>\n<p>re: soundness bug, I believe I don\u2019t follow your concerns, unless you\u2019re specifically talking about snapshot reads done without adding conflict ranges, which I don\u2019t think you are.  There\u2019s a couple pieces I\u2019m confused about.</p>\n<p>I specifically don\u2019t follow the \u201csnapshot reads aren\u2019t serializable\u201d part.  I would claim that they are serializable, and are serialized at the end of their read version, as you had noted previously.  This would complicate the implementation slightly by having to make sure to get them ordered in with the recorded commits correctly, but not the soundness.</p>\n<p>For read-write transactions, suppose we\u2019re checking a schedule of transactions [T1 {r:0, w:1}, T2{r:0, w:2}, T3{r:1,w:3}], where <code>r:</code> specifies its read version and <code>w:</code> specifies its commit version.  Suppose that there\u2019s a key K that was written by T1.  When validating a read of key K in T3, we\u2019ll have two cases to consider:  either K was written by T2, or K was not written by T2.  If K was not written by T2, then the most recently written version of K would be T1\u2019s write.  If K was written by T2, then T3 should not have committed, and any error reported would be correctly reported.  So I don\u2019t see a soundness issue there either.</p>\n<p>This is all to say, I believe that I\u2019m misunderstanding your point, and would you mind illustrating your comment slightly more?</p>",
        "post_number": 6,
        "post_type": 1,
        "posts_count": 11,
        "updated_at": "2018-04-27T23:08:54.251Z",
        "reply_count": 1,
        "reply_to_post_number": 5,
        "quote_count": 0,
        "incoming_link_count": 1,
        "reads": 54,
        "readers_count": 53,
        "score": 20.8,
        "yours": false,
        "topic_id": 289,
        "topic_slug": "a-precise-test-oracle-for-foundationdb-simulation-workloads",
        "display_username": "Alex Miller",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "reply_to_user": {
          "id": 22,
          "username": "dave",
          "name": "David Scherer",
          "avatar_template": "/user_avatar/forums.foundationdb.org/dave/{size}/89_2.png"
        },
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 13,
        "hidden": false,
        "trust_level": 4,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/a-precise-test-oracle-for-foundationdb-simulation-workloads/289/6",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 672,
        "name": "David Scherer",
        "username": "dave",
        "avatar_template": "/user_avatar/forums.foundationdb.org/dave/{size}/89_2.png",
        "created_at": "2018-04-27T23:29:05.444Z",
        "cooked": "<p>I exactly mean snapshot reads done without adding conflict ranges.  They need to be checked at the snapshot version (as if in a read only transaction of their own), not at the commit version.  This is pretty obvious in hindsight, but I didn\u2019t actually say it in my original proposal; that\u2019s the soundness bug.  (I don\u2019t actually know if \u201csoundness\u201d and \u201cprecision\u201d are the best words for the two types of errors but I think it\u2019s clear from context what I mean)</p>\n<p>And if you check all snapshot reads only at the snapshot version, <em>then</em> <span class=\"hashtag\">#126</span> isn\u2019t detected, and as you say just checking if the read is upgraded still doesn\u2019t seem to be precise.</p>\n<p>So I think I support the idea of explicitly checking that the serialization history respects the specified conflict ranges, in addition to checking snapshot reads at the snapshot version and explicitly serializable reads at the commit version.  (The latter is kind of optional, I guess, but a valuable belt and suspenders that could detect some unknown unknown that breaks the isolation property we actually want while somehow following the rules about conflicts.  And I don\u2019t think there\u2019s any intended API feature for \u201cdowngrading\u201d a read once you have made it serializably.)</p>\n<p>Unfortunately I thought of another source of complexity.  Evan\u2019s comment about RYW being complicated to model is <em>also</em> possibly true of snapshot reads in that design.  Snapshot reads are supposed to see previous writes in the same transaction, and I guess we would have to model that if we are \u201cmoving\u201d them to the snapshot version.</p>\n<p>Let me know if this is clear.</p>\n<p>Regarding view serializability, for what it\u2019s worth I guess the two methods this oracle can use to identify serialization order are evidence that the exact serialization order is nearly always observable in FDB <code>:-)</code></p>",
        "post_number": 7,
        "post_type": 1,
        "posts_count": 11,
        "updated_at": "2018-04-27T23:29:05.444Z",
        "reply_count": 1,
        "reply_to_post_number": 6,
        "quote_count": 0,
        "incoming_link_count": 0,
        "reads": 50,
        "readers_count": 49,
        "score": 15.0,
        "yours": false,
        "topic_id": 289,
        "topic_slug": "a-precise-test-oracle-for-foundationdb-simulation-workloads",
        "display_username": "David Scherer",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "reply_to_user": {
          "id": 13,
          "username": "alexmiller",
          "name": "Alex Miller",
          "avatar_template": "/user_avatar/forums.foundationdb.org/alexmiller/{size}/326_2.png"
        },
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 22,
        "hidden": false,
        "trust_level": 1,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/a-precise-test-oracle-for-foundationdb-simulation-workloads/289/7",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 682,
        "name": "Alec Grieser",
        "username": "alloc",
        "avatar_template": "/user_avatar/forums.foundationdb.org/alloc/{size}/9_2.png",
        "created_at": "2018-04-29T00:15:53.715Z",
        "cooked": "<p>Hm, well, I guess that since the oracle is supposed to say whether the transactions were consistent with the supposed serial order (provided by versionstamps), it isn\u2019t surprising that it is complicated to make it work with the parts of API that allow the user to massage that guarantee (i.e., add snapshot reads so that mean transactions might not actually be serializable or add conflict ranges so that certain serial orderings are actually invalid). It might be the case that there is value in a test that doesn\u2019t worry about those complexities and just verifies that if you use the database with only serializable reads and writes, the serialized order actually is correct.</p>\n<p>That being said, I think the following modifications would allow this test to encompass the whole API (without requiring it explicitly check conflict ranges):</p>\n<ol>\n<li>When doing a snapshot read, one should also do it in a fresh transaction at the same read version without the RYW behavior. Write that value at the read version as a serialized read. Then also write the value that was <em>actually</em> read at the commit version as a snapshot read. Then verify that the two values are the same when the test has completed (except account for mutations that have happened within the same transaction, i.e., reimplement RYW and use it here, unless the disableSnapshotRYW option has been set).</li>\n<li>For every manual read conflict range, perform a read in that other fresh transaction with the same read version, but serialize it as the first things that happened within the transaction at the commit version (or at least before all writes). (I believe this would catch <span class=\"hashtag\">#126</span>.)</li>\n<li>The in-memory data structure being used to validate correctness should keep, in addition to the value of a key, the version at which it was modified. For range clears, you will need a tombstone that includes the end key, and during sets, you might have to split the tombstones apart.</li>\n<li>When a write conflict range is added manually, only the \u201clast modified version\u201d of keys in the range need to be updated. (This also protects against problems where a transaction sets a key to the same value that it was before, which might slip through the cracks of the original test, if we want to call that a definiciency.)</li>\n<li>When validating a read, one should check that the value read is the same as the value in the in-memory validating structure, but also, one should check that the last modified version of those keys is less than or equal to the read version.</li>\n</ol>\n<p>I think (think) that this should verify the contract. Note that some of those steps are essentially equivalent to just checking the conflict ranges, but like, I think this might be as close as one can get before giving up and just re-implementing the resolver (maybe less optimized under the assumption that it\u2019s less error-prone to write less optimized code and maybe without the need to have efficient truncation).</p>\n<p>At present, I believe it only validates that the purported serialized order is a valid serialized order, but it does not validate that the order isn\u2019t too pessimistic. (In other words, I think a transaction resolver that just says \u201cno\u201d to all transactions passes the test.) To fix <em>that</em>, if you can get the versionstamp associated with <em>uncommitted</em> transactions (which exists but isn\u2019t exposed in our API), then you could store somewhere in memory on the side all reads (including read conflict ranges but not snapshot reads) and verify that something in the committed serial sequence has changed (again, using the \u201clast modified version\u201d plus value combo). (Except that <em>that</em> doesn\u2019t work in the presence of multiple resolvers, because they actually are more pessimistic than is strictly necessary even without bugs. Hmph.)</p>\n<hr>\n<p>I will also add that this test doesn\u2019t have to be done in simulation (or, rather, it doesn\u2019t only have to be done at the key and value level). If an application developer has a layer that can be modeled in-memory, and they want to validate that their operations, in the presence of concurrent actors, still works correctly, then can use their layer while also transactionally maintaining a log of their operations. This is particularly useful if they do things like mess with conflict ranges in order to decrease contention and want to validate that they still produce operations that ultimately serialize correctly. (For example, if you had application that popped things from a queue by reading the first n elements at snapshot isolation level and then picking one randomly, you could validate that each queue item is popped exactly once with a scheme like this.) It is probably hard to make a test like this validate that the conflict ranges aren\u2019t too big (i.e., that there weren\u2019t operations that \u201ccould\u201d have been committed but weren\u2019t), but often, it\u2019s probably good enough just to validate that they aren\u2019t too small (i.e., that there aren\u2019t any operations that shouldn\u2019t have been committed but were).</p>",
        "post_number": 8,
        "post_type": 1,
        "posts_count": 11,
        "updated_at": "2018-04-29T00:15:53.715Z",
        "reply_count": 0,
        "reply_to_post_number": 7,
        "quote_count": 0,
        "incoming_link_count": 1,
        "reads": 46,
        "readers_count": 45,
        "score": 14.2,
        "yours": false,
        "topic_id": 289,
        "topic_slug": "a-precise-test-oracle-for-foundationdb-simulation-workloads",
        "display_username": "Alec Grieser",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "reply_to_user": {
          "id": 22,
          "username": "dave",
          "name": "David Scherer",
          "avatar_template": "/user_avatar/forums.foundationdb.org/dave/{size}/89_2.png"
        },
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 8,
        "hidden": false,
        "trust_level": 4,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/a-precise-test-oracle-for-foundationdb-simulation-workloads/289/8",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 712,
        "name": "David Scherer",
        "username": "dave",
        "avatar_template": "/user_avatar/forums.foundationdb.org/dave/{size}/89_2.png",
        "created_at": "2018-04-29T16:21:15.530Z",
        "cooked": "<p>A slowish implementation of range conflict checking shouldn\u2019t be too hard; in fact there is a SlowConflictSet implemented in a few lines in Skiplist.cpp for use in (apparently defunct) unit tests there!</p>\n<p>I\u2019m not sure, but Alec I think your proposal largely boils down to mixing the conflict checking (in the form of verifying last modified versions) in with verifying reads.</p>\n<p>Rather than duplicate RYW (yuck) I think I might try to support (single) checkpoint/rollback of the fake kv store with a simple undo log. So you do all reads and writes of a transaction in order at its snapshot version, then roll them back. Then at the commit version you do serializable reads, writes, and conflict checking. Would that work? I think it\u2019s unlikely to have the exact same bugs as the real database.</p>",
        "post_number": 9,
        "post_type": 1,
        "posts_count": 11,
        "updated_at": "2018-04-29T16:21:15.530Z",
        "reply_count": 1,
        "reply_to_post_number": null,
        "quote_count": 0,
        "incoming_link_count": 0,
        "reads": 42,
        "readers_count": 41,
        "score": 13.4,
        "yours": false,
        "topic_id": 289,
        "topic_slug": "a-precise-test-oracle-for-foundationdb-simulation-workloads",
        "display_username": "David Scherer",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 22,
        "hidden": false,
        "trust_level": 1,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/a-precise-test-oracle-for-foundationdb-simulation-workloads/289/9",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 716,
        "name": "Alec Grieser",
        "username": "alloc",
        "avatar_template": "/user_avatar/forums.foundationdb.org/alloc/{size}/9_2.png",
        "created_at": "2018-04-29T20:54:55.193Z",
        "cooked": "<aside class=\"quote no-group\" data-username=\"dave\" data-post=\"9\" data-topic=\"289\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/dave/48/89_2.png\" class=\"avatar\"> dave:</div>\n<blockquote>\n<p>I\u2019m not sure, but Alec I think your proposal largely boils down to mixing the conflict checking (in the form of verifying last modified versions) in with verifying reads.</p>\n</blockquote>\n</aside>\n<p>Yeah, that sounds right. I suppose that there\u2019s argument somewhere that it is better than just running a SlowConflictSet on the side in that you are verifying that your read conflict ranges aren\u2019t stale by actually reading them, which is a more direct test than relying on the SlowConflictSet, but maybe that\u2019s marginal.</p>\n<aside class=\"quote no-group\" data-username=\"dave\" data-post=\"9\" data-topic=\"289\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://sea1.discourse-cdn.com/foundationdb/user_avatar/forums.foundationdb.org/dave/48/89_2.png\" class=\"avatar\"> dave:</div>\n<blockquote>\n<p>Rather than duplicate RYW (yuck) I think I might try to support (single) checkpoint/rollback of the fake kv store with a simple undo log. So you do all reads and writes of a transaction in order at its snapshot version, then roll them back. Then at the commit version you do serializable reads, writes, and conflict checking. Would that work? I think it\u2019s unlikely to have the exact same bugs as the real database.</p>\n</blockquote>\n</aside>\n<p>Hm, I think that would work. It does seem like an undo log, given that FDB doesn\u2019t use any undo logs anywhere else, is likely to have a different set of bugs than the real database, so maybe that\u2019s a plus, but it does seem annoying that one would have to implement \u201cundo a clear range\u201d to make it work. And your writes here would either have to exclude SET_VERSIONSTAMPED_KEY and SET_VERSIONSTAMPED_VALUE mutations (or include them, but reads are now just verifying that none of your reads looked at them \u00e0 la unreadable ranges in the RYW cache).</p>\n<p>One benefit that the test verifier has over the real database when it comes to implementing RYW is that it doesn\u2019t have to be concerned with also being the read cache or with being efficient, so reading a range with RYW could even be implemented as (1) read the range at the old version (i.e., without YW) then (2) apply all mutations in order. I claim (without proof) that that shouldn\u2019t be too hard to implement (at least easier than the <em>real</em> RYW cache). You could then implement the single-checkpoint in-memory DB you mentioned as one map containing the current DB state and a list of uncommitted mutations, and then \u201crollback\u201d is just forgetting the mutation list.</p>\n<p>By conflict checking, do you mean that you could check all (manually- and possibly also automatically-added) read conflict ranges against a SlowConflictSet and add all write conflict ranges at the end to the same set? I do think that that would work, and it would probably necessary if you don\u2019t keep most-recently-modified version information with all of the keys in the in-memory representation to catch certain classes of bugs. I guess I\u2019m somewhat concerned that the SlowConflictSet might have the same set of bugs as the main resolution skip list, which is partially why I suggested keeping most-recently-modified metadata around.</p>\n<p>I suppose one other benefit is that if you had uncommitted transactions somewhere, then you can simulate what is \u201csupposed\u201d to happen with multiple resolvers by using multiple SlowConflictSets and dirtying them with uncommitted transactions that failed only on the other resolvers. But at this point, the tester is trying pretty hard to simulate the database itself rather than just verify its contract. Hm.</p>",
        "post_number": 10,
        "post_type": 1,
        "posts_count": 11,
        "updated_at": "2018-04-29T20:54:55.193Z",
        "reply_count": 1,
        "reply_to_post_number": 9,
        "quote_count": 1,
        "incoming_link_count": 4,
        "reads": 45,
        "readers_count": 44,
        "score": 34.0,
        "yours": false,
        "topic_id": 289,
        "topic_slug": "a-precise-test-oracle-for-foundationdb-simulation-workloads",
        "display_username": "Alec Grieser",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 8,
        "hidden": false,
        "trust_level": 4,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/a-precise-test-oracle-for-foundationdb-simulation-workloads/289/10",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 719,
        "name": "David Scherer",
        "username": "dave",
        "avatar_template": "/user_avatar/forums.foundationdb.org/dave/{size}/89_2.png",
        "created_at": "2018-04-30T00:17:47.601Z",
        "cooked": "<p>I think that continuing to check that serialized reads are serializable is a decent defense against bugs (which probably mean conceptual errors) that affect both SlowConflictSet and the real resolution machinery.  I think you are down to problems that (1) like issue <span class=\"hashtag\">#126</span>, don\u2019t affect regular serializable reads, AND (2) affect the determination of conflict ranges in the oracle\u2019s transaction wrapper as well as in the client implementation.  This is not totally inconceivable, especially when we are talking about poorly specified new features, but I can\u2019t really think of a way to do better.</p>\n<p>An undo log for this purpose isn\u2019t too hard, I don\u2019t think.  Unlike the real database amortized performance is fine.  Ignoring lifetimes to an extent, basically something like</p>\n<pre><code>void beginTransaction() {\n    ASSERT( !inTxn );\n    inTxn = true;\n}\nvoid commitTransaction() {\n    ASSERT( inTxn );\n    undoLog.clear();\n    inTxn = false;\n}\nvoid rollbackTransaction() {\n    ASSERT( inTxn );\n    inTxn = false;\n    for( auto const&amp; item : reversed(undoLog) )\n        if (item.value.present())\n            set( KeyRangeRef( item.key, item.value.get() ) );\n        else\n            clear( KeyRangeRef( item.key, keyAfter( item.key ) ) );\n    undoLog.clear();\n}\nvoid setRange( KeyValueRef kv ) {\n    if (inTxn) {\n        Optional&lt;ValueRef&gt; v = get( kv.key );\n        undoLog.push_back( KeyMaybeValueRef( kv.key, v ) );\n    }\n    map[kv.key] = kv.value;\n}\nvoid clearRange( KeyRangeRef range ) {\n    if (inTxn)\n        for(auto const&amp; it : getRange( range ))\n            undoLog.push_back( KeyMaybeValueRef( it.first, it.second ) );\n    map.erase( range );\n}\n</code></pre>\n<p>etc.  A separate unit test is probably unnecessary given that it will be tested very extensively by the oracle test itself.</p>\n<p>I guess ideally you might want to have this fake K/V store support unreadable ranges to deal with the SET_VERSIONSTAMPED_KEY issue, or else check that separately.</p>",
        "post_number": 11,
        "post_type": 1,
        "posts_count": 11,
        "updated_at": "2018-04-30T00:20:48.941Z",
        "reply_count": 0,
        "reply_to_post_number": 10,
        "quote_count": 0,
        "incoming_link_count": 1,
        "reads": 41,
        "readers_count": 40,
        "score": 13.2,
        "yours": false,
        "topic_id": 289,
        "topic_slug": "a-precise-test-oracle-for-foundationdb-simulation-workloads",
        "display_username": "David Scherer",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 2,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "reply_to_user": {
          "id": 8,
          "username": "alloc",
          "name": "Alec Grieser",
          "avatar_template": "/user_avatar/forums.foundationdb.org/alloc/{size}/9_2.png"
        },
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 22,
        "hidden": false,
        "trust_level": 1,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/a-precise-test-oracle-for-foundationdb-simulation-workloads/289/11",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      }
    ],
    "stream": [
      649,
      659,
      662,
      663,
      669,
      671,
      672,
      682,
      712,
      716,
      719
    ]
  },
  "timeline_lookup": [
    [
      1,
      2734
    ],
    [
      8,
      2733
    ],
    [
      9,
      2732
    ]
  ],
  "suggested_topics": [],
  "tags": [],
  "tags_descriptions": {},
  "fancy_title": "A precise test oracle for FoundationDB simulation workloads",
  "id": 289,
  "title": "A precise test oracle for FoundationDB simulation workloads",
  "posts_count": 11,
  "created_at": "2018-04-27T14:04:16.394Z",
  "views": 1249,
  "reply_count": 7,
  "like_count": 0,
  "last_posted_at": "2018-04-30T00:17:47.601Z",
  "visible": true,
  "closed": false,
  "archived": false,
  "has_summary": false,
  "archetype": "regular",
  "slug": "a-precise-test-oracle-for-foundationdb-simulation-workloads",
  "category_id": 8,
  "word_count": 3786,
  "deleted_at": null,
  "user_id": 22,
  "featured_link": null,
  "pinned_globally": false,
  "pinned_at": null,
  "pinned_until": null,
  "image_url": null,
  "slow_mode_seconds": 0,
  "draft": null,
  "draft_key": "topic_289",
  "draft_sequence": null,
  "unpinned": null,
  "pinned": false,
  "current_post_number": 1,
  "highest_post_number": 11,
  "deleted_by": null,
  "actions_summary": [
    {
      "id": 4,
      "count": 0,
      "hidden": false,
      "can_act": false
    },
    {
      "id": 8,
      "count": 0,
      "hidden": false,
      "can_act": false
    },
    {
      "id": 10,
      "count": 0,
      "hidden": false,
      "can_act": false
    },
    {
      "id": 7,
      "count": 0,
      "hidden": false,
      "can_act": false
    }
  ],
  "chunk_size": 20,
  "bookmarked": false,
  "topic_timer": null,
  "message_bus_last_id": 0,
  "participant_count": 4,
  "show_read_indicator": false,
  "thumbnails": null,
  "slow_mode_enabled_until": null,
  "tags_disable_ads": false,
  "related_topics": [
    {
      "fancy_title": "Questions regarding FDB transaction conflict on two concurrent transactions",
      "id": 2913,
      "title": "Questions regarding FDB transaction conflict on two concurrent transactions",
      "slug": "questions-regarding-fdb-transaction-conflict-on-two-concurrent-transactions",
      "posts_count": 10,
      "reply_count": 5,
      "highest_post_number": 10,
      "image_url": null,
      "created_at": "2021-09-28T06:26:34.642Z",
      "last_posted_at": "2021-10-28T08:17:02.264Z",
      "bumped": true,
      "bumped_at": "2021-10-28T09:13:59.130Z",
      "archetype": "regular",
      "unseen": false,
      "pinned": false,
      "unpinned": null,
      "visible": true,
      "closed": false,
      "archived": false,
      "bookmarked": null,
      "liked": null,
      "tags": [],
      "tags_descriptions": {},
      "like_count": 3,
      "views": 2185,
      "category_id": 7,
      "featured_link": null,
      "has_accepted_answer": false,
      "posters": [
        {
          "extras": null,
          "description": "Original Poster",
          "user": {
            "id": 550,
            "username": "ntrhieu89",
            "name": "Hieu Nguyen",
            "avatar_template": "/user_avatar/forums.foundationdb.org/ntrhieu89/{size}/587_2.png",
            "trust_level": 1
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 12,
            "username": "ajbeamon",
            "name": "A.J. Beamon",
            "avatar_template": "/user_avatar/forums.foundationdb.org/ajbeamon/{size}/13_2.png",
            "admin": true,
            "trust_level": 4
          }
        },
        {
          "extras": "latest",
          "description": "Most Recent Poster",
          "user": {
            "id": 13,
            "username": "alexmiller",
            "name": "Alex Miller",
            "avatar_template": "/user_avatar/forums.foundationdb.org/alexmiller/{size}/326_2.png",
            "trust_level": 4
          }
        }
      ]
    },
    {
      "fancy_title": "A few design-pattern + check-my-understanding questions",
      "id": 1153,
      "title": "A few design-pattern + check-my-understanding questions",
      "slug": "a-few-design-pattern-check-my-understanding-questions",
      "posts_count": 10,
      "reply_count": 6,
      "highest_post_number": 10,
      "image_url": null,
      "created_at": "2019-02-19T15:18:58.329Z",
      "last_posted_at": "2019-02-21T19:51:53.686Z",
      "bumped": true,
      "bumped_at": "2019-02-21T19:51:53.686Z",
      "archetype": "regular",
      "unseen": false,
      "pinned": false,
      "unpinned": null,
      "visible": true,
      "closed": false,
      "archived": false,
      "bookmarked": null,
      "liked": null,
      "tags": [],
      "tags_descriptions": {},
      "like_count": 1,
      "views": 2273,
      "category_id": 7,
      "featured_link": null,
      "has_accepted_answer": false,
      "posters": [
        {
          "extras": null,
          "description": "Original Poster",
          "user": {
            "id": 519,
            "username": "JamesThompson",
            "name": "James Thompson",
            "avatar_template": "https://avatars.discourse-cdn.com/v4/letter/j/c67d28/{size}.png",
            "trust_level": 1
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 173,
            "username": "jkominek",
            "name": "Jay Kominek",
            "avatar_template": "/user_avatar/forums.foundationdb.org/jkominek/{size}/140_2.png",
            "trust_level": 2
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 12,
            "username": "ajbeamon",
            "name": "A.J. Beamon",
            "avatar_template": "/user_avatar/forums.foundationdb.org/ajbeamon/{size}/13_2.png",
            "admin": true,
            "trust_level": 4
          }
        },
        {
          "extras": "latest",
          "description": "Most Recent Poster",
          "user": {
            "id": 53,
            "username": "KrzysFR",
            "name": "Christophe Chevalier",
            "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
            "trust_level": 2
          }
        }
      ]
    },
    {
      "fancy_title": "Technical overview of the database",
      "id": 135,
      "title": "Technical overview of the database",
      "slug": "technical-overview-of-the-database",
      "posts_count": 27,
      "reply_count": 15,
      "highest_post_number": 27,
      "image_url": null,
      "created_at": "2018-04-20T15:30:31.788Z",
      "last_posted_at": "2019-01-11T23:25:47.462Z",
      "bumped": true,
      "bumped_at": "2019-01-11T23:25:47.462Z",
      "archetype": "regular",
      "unseen": false,
      "pinned": false,
      "unpinned": null,
      "visible": true,
      "closed": false,
      "archived": false,
      "bookmarked": null,
      "liked": null,
      "tags": [],
      "tags_descriptions": {},
      "like_count": 64,
      "views": 12958,
      "category_id": 7,
      "featured_link": null,
      "has_accepted_answer": false,
      "posters": [
        {
          "extras": null,
          "description": "Original Poster",
          "user": {
            "id": 96,
            "username": "idiot",
            "name": "",
            "avatar_template": "https://avatars.discourse-cdn.com/v4/letter/i/f04885/{size}.png",
            "trust_level": 1
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 22,
            "username": "dave",
            "name": "David Scherer",
            "avatar_template": "/user_avatar/forums.foundationdb.org/dave/{size}/89_2.png",
            "trust_level": 1
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 13,
            "username": "alexmiller",
            "name": "Alex Miller",
            "avatar_template": "/user_avatar/forums.foundationdb.org/alexmiller/{size}/326_2.png",
            "trust_level": 4
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 443,
            "username": "junius",
            "name": "junius",
            "avatar_template": "https://avatars.discourse-cdn.com/v4/letter/j/f08c70/{size}.png",
            "trust_level": 1
          }
        },
        {
          "extras": "latest",
          "description": "Most Recent Poster",
          "user": {
            "id": 54,
            "username": "Evan",
            "name": "Evan Tschannen",
            "avatar_template": "/user_avatar/forums.foundationdb.org/evan/{size}/104_2.png",
            "moderator": true,
            "trust_level": 1
          }
        }
      ]
    },
    {
      "fancy_title": "Optimizing a single large transaction ( 10,000 keys)",
      "id": 1961,
      "title": "Optimizing a single large transaction ( 10,000 keys)",
      "slug": "optimizing-a-single-large-transaction-10-000-keys",
      "posts_count": 12,
      "reply_count": 10,
      "highest_post_number": 12,
      "image_url": null,
      "created_at": "2020-02-17T13:36:55.355Z",
      "last_posted_at": "2020-02-24T11:30:42.854Z",
      "bumped": true,
      "bumped_at": "2020-02-24T11:30:42.854Z",
      "archetype": "regular",
      "unseen": false,
      "pinned": false,
      "unpinned": null,
      "visible": true,
      "closed": false,
      "archived": false,
      "bookmarked": null,
      "liked": null,
      "tags": [
        "performance"
      ],
      "tags_descriptions": {},
      "like_count": 1,
      "views": 2373,
      "category_id": 7,
      "featured_link": null,
      "has_accepted_answer": false,
      "posters": [
        {
          "extras": null,
          "description": "Original Poster",
          "user": {
            "id": 645,
            "username": "subramaniamr",
            "name": "Subramaniam R",
            "avatar_template": "/user_avatar/forums.foundationdb.org/subramaniamr/{size}/658_2.png",
            "trust_level": 2
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 8,
            "username": "alloc",
            "name": "Alec Grieser",
            "avatar_template": "/user_avatar/forums.foundationdb.org/alloc/{size}/9_2.png",
            "trust_level": 4
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 13,
            "username": "alexmiller",
            "name": "Alex Miller",
            "avatar_template": "/user_avatar/forums.foundationdb.org/alexmiller/{size}/326_2.png",
            "trust_level": 4
          }
        },
        {
          "extras": "latest",
          "description": "Most Recent Poster",
          "user": {
            "id": 166,
            "username": "gaurav",
            "name": "gaurav",
            "avatar_template": "https://avatars.discourse-cdn.com/v4/letter/g/b487fb/{size}.png",
            "trust_level": 3
          }
        }
      ]
    },
    {
      "fancy_title": "Understanding inter communication",
      "id": 745,
      "title": "Understanding inter communication",
      "slug": "understanding-inter-communication",
      "posts_count": 12,
      "reply_count": 7,
      "highest_post_number": 12,
      "image_url": null,
      "created_at": "2018-10-05T00:51:33.531Z",
      "last_posted_at": "2018-10-11T17:16:52.613Z",
      "bumped": true,
      "bumped_at": "2018-10-11T17:16:52.613Z",
      "archetype": "regular",
      "unseen": false,
      "pinned": false,
      "unpinned": null,
      "visible": true,
      "closed": false,
      "archived": false,
      "bookmarked": null,
      "liked": null,
      "tags": [],
      "tags_descriptions": {},
      "like_count": 10,
      "views": 3588,
      "category_id": 7,
      "featured_link": null,
      "has_accepted_answer": false,
      "posters": [
        {
          "extras": "latest",
          "description": "Original Poster, Most Recent Poster",
          "user": {
            "id": 384,
            "username": "Chandru4u",
            "name": "Chandrashekar",
            "avatar_template": "https://avatars.discourse-cdn.com/v4/letter/c/b487fb/{size}.png",
            "trust_level": 1
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 8,
            "username": "alloc",
            "name": "Alec Grieser",
            "avatar_template": "/user_avatar/forums.foundationdb.org/alloc/{size}/9_2.png",
            "trust_level": 4
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 13,
            "username": "alexmiller",
            "name": "Alex Miller",
            "avatar_template": "/user_avatar/forums.foundationdb.org/alexmiller/{size}/326_2.png",
            "trust_level": 4
          }
        }
      ]
    }
  ],
  "summarizable": false,
  "can_vote": false,
  "vote_count": 0,
  "user_voted": false,
  "discourse_zendesk_plugin_zendesk_id": null,
  "discourse_zendesk_plugin_zendesk_url": "https://your-url.zendesk.com/agent/tickets/",
  "details": {
    "can_edit": false,
    "notification_level": 1,
    "participants": [
      {
        "id": 22,
        "username": "dave",
        "name": "David Scherer",
        "avatar_template": "/user_avatar/forums.foundationdb.org/dave/{size}/89_2.png",
        "post_count": 6,
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_color": null,
        "flair_bg_color": null,
        "flair_group_id": null,
        "trust_level": 1
      },
      {
        "id": 8,
        "username": "alloc",
        "name": "Alec Grieser",
        "avatar_template": "/user_avatar/forums.foundationdb.org/alloc/{size}/9_2.png",
        "post_count": 2,
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_color": null,
        "flair_bg_color": null,
        "flair_group_id": null,
        "trust_level": 4
      },
      {
        "id": 13,
        "username": "alexmiller",
        "name": "Alex Miller",
        "avatar_template": "/user_avatar/forums.foundationdb.org/alexmiller/{size}/326_2.png",
        "post_count": 2,
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_color": null,
        "flair_bg_color": null,
        "flair_group_id": null,
        "trust_level": 4
      },
      {
        "id": 54,
        "username": "Evan",
        "name": "Evan Tschannen",
        "avatar_template": "/user_avatar/forums.foundationdb.org/evan/{size}/104_2.png",
        "post_count": 1,
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_color": null,
        "flair_bg_color": null,
        "flair_group_id": null,
        "moderator": true,
        "trust_level": 1
      }
    ],
    "created_by": {
      "id": 22,
      "username": "dave",
      "name": "David Scherer",
      "avatar_template": "/user_avatar/forums.foundationdb.org/dave/{size}/89_2.png"
    },
    "last_poster": {
      "id": 22,
      "username": "dave",
      "name": "David Scherer",
      "avatar_template": "/user_avatar/forums.foundationdb.org/dave/{size}/89_2.png"
    },
    "links": [
      {
        "url": "https://github.com/apple/foundationdb/issues/126",
        "title": "Adding an explicit read conflict range skips the keys in write cache \u00b7 Issue #126 \u00b7 apple/foundationdb \u00b7 GitHub",
        "internal": false,
        "attachment": false,
        "reflection": false,
        "clicks": 35,
        "user_id": 22,
        "domain": "github.com",
        "root_domain": "github.com"
      }
    ]
  },
  "bookmarks": []
}