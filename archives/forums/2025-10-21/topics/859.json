{
  "post_stream": {
    "posts": [
      {
        "id": 2616,
        "name": "Christophe Chevalier",
        "username": "KrzysFR",
        "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
        "created_at": "2018-11-10T14:52:35.460Z",
        "cooked": "<p>Reviewing some code under a profiler, I\u2019m seeing more and more frequently the same issue popping up: most of the CPU time (in app or layer code) is spent generating binary keys, and especially allocating buffers, copying bytes from one buffer to another, resizing the buffer because it was too small, etc\u2026</p>\n<p>The typical key generated in my apps is usually a tuple composed of a few items, that are appended to a directory subspace\u2019s prefix. Typical code to generate a single key looks like <code>subspace.Keys.Encode(\"Hello\", 123)</code> that turns into <code>{PARTITION_PREFIX}.{SUBSPACE_PREFIX}.{02 'H' 'e' 'l' 'l' 'o' 00}.{15 7B}</code>.</p>\n<p>With some layers, the subspace prefix could even contain strings (at least during the initial prototype phase, I like to use strings (like \u201cFoos\u201d, \u201cBars\u201d, \u201cFoosByBarId\u201d, \u2026). You can also have a lot of large UUID-like values that are repeated multiple times (when doing index lookups under categories).</p>\n<p>In the end, the process always look like:</p>\n<ul>\n<li>allocate a buffer (probably too small) or take it from some pool</li>\n<li>write the prefix of the subspace (a couple of bytes up to a few dozens)</li>\n<li>for each item in the tuple\n<ul>\n<li>append the encoded representation of the item</li>\n<li><em>propably at some time, have to resize the buffer (alloc a larger one, copy, throw away the previous one)</em></li>\n</ul>\n</li>\n<li>return a span over the buffer that has been filled</li>\n<li>pass that to the fdb client API</li>\n<li>throw away the buffer, or if we are lucky, know that it is safe to put it back in the pool.</li>\n</ul>\n<p>Repeat that for potentially thousands of keys (in a typical index query that must then do a lookup in the original document) and most of the time is spent moving bytes in memory, before finally passing them to the C API, again and again.</p>\n<p>One way to maybe help solve this issue, would be to be able to pass a <em>list</em> of buffers instead of a <em>single</em> buffer to most APIs that take keys. The actual key would be the concatenation of the all buffers, or chunks, that are passed.</p>\n<p>For example, in addition of the classic <code>fdb_transaction_set(FDBTransaction* transaction, uint8_t const* key_name, int key_name_length, uint8_t const* value, int value_length)</code>, we would be able to pass a list of <code>(pointer, length)</code> as the key:</p>\n<pre><code class=\"lang-auto\">typedef struct {\n    uint8_t const* start; // pointer to the first byte of the chunk\n    int length;               // number of consecutive bytes to read\n} KeyChunk;\n\nfdb_transaction_set_chunks(\n    FDBTransaction* transaction,\n    KeyChunk const* key_chunks, // pointer to an array of KeyChunk structs\n    int key_chunks_length,      // length of the chunk array\n    uint8_t const* value,\n    int value_length\n)\n</code></pre>\n<p>Under the hood, the C API could then concat all chunks back together in its own buffer before calling back into the original <code>fdb_transaction_set</code> (or into the same internal implementation)</p>\n<p>In the typical case of a composite keys with a subspace prefix, I could simply cache the subspace prefix in a buffer, and only generated the end of the key in another buffer, and pass an array of 2 or 3 key \u201cchunks\u201d.</p>\n<p>When working with tuples and small integers, I can simply <em>cache</em> all encoded versions of numbers from say 1 to 1000, and simply pass a pointer to that, instead of having to copy the bytes. The complete key could be a list of chunks, some of them pointing to cached pre-encoded buffers, while others pointing to a single buffer that contain the non-cached encoded portion of the key.</p>\n<p>Sample layer code (in pseudo code)</p>\n<pre><code class=\"lang-auto\">KeyChunk[] keyParts = stackalloc KeyChunk[3]; // allocate on stack, so very cheap\nkeyParts[0] = subspace.GetCachedPrefixKeyChunk(); // cached and reused frequently\nkeyParts[1] = SomeEncoder.EncodeString(\"Hello\"); // will probably allocate buf only a few bytes\nkeyParts[2] = SomeEncoder.EncodeInteger(123); // will probably used a cached buffer for 123 because it is a small integer\n\nfdb_transaction_set_chunks(\n    tr.Handle,\n    &amp;keyParts,\n    keyParts.Length,\n    &amp;value[0],\n    value.Length\n);\n</code></pre>\n<p>Another use case: usually when generating a key range from a key prefix <code>\"AVeryLongPrefixABC\"</code>, and when you need to inclement the last byte to generate <code>[ \"AVeryLongPrefixABC\", \"AVeryLongPrefixABD\" ]</code>, I cannot reuse the same buffer for the two bounds, because the last byte is different. With key chunks, for the end key, I could reuse the buffer for the first key (minus the last byte) and then have an extra chunk that points to the single <code>'D'</code> byte (and again here I can have a cached 256-byte long buffer with all bytes from 0 to 255 and point to that). Basically here, I can generate a range without doing any memory allocation.</p>\n<p>Any opinions on this?</p>",
        "post_number": 1,
        "post_type": 1,
        "posts_count": 4,
        "updated_at": "2018-11-12T19:15:42.872Z",
        "reply_count": 0,
        "reply_to_post_number": null,
        "quote_count": 0,
        "incoming_link_count": 26,
        "reads": 31,
        "readers_count": 30,
        "score": 138.2,
        "yours": false,
        "topic_id": 859,
        "topic_slug": "adding-new-apis-to-specify-keys-as-a-list-of-chunks-allowing-zero-copy-serialization",
        "display_username": "Christophe Chevalier",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 4,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 53,
        "hidden": false,
        "trust_level": 2,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/adding-new-apis-to-specify-keys-as-a-list-of-chunks-allowing-zero-copy-serialization/859/1",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null,
        "can_vote": false
      },
      {
        "id": 2628,
        "name": "Alec Grieser",
        "username": "alloc",
        "avatar_template": "/user_avatar/forums.foundationdb.org/alloc/{size}/9_2.png",
        "created_at": "2018-11-12T17:58:19.492Z",
        "cooked": "<p>I could see the utility here, though if the FDB client has to reconstitute the list of keys into a single key, then I\u2019m not sure the gains will be all that large. In particular, it seems like it would take CPU work that is currently in the user\u2019s threads and push it to the network thread, which might actually degrade performance (as the C client is single threaded).</p>\n<p>It\u2019s possible that the <em>bindings</em> should do more of this kind of caching, and then they can do zero-copy operations (or only copy buffer pointers rather than buffers themselves) and only serialize everything into a single byte array right before handing the value to the FDB C client. (Kind of like Protocol Buffers <a href=\"https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/ByteString\">ByteString</a>s, which, minus the caching, do much of this, especially the <a href=\"https://github.com/protocolbuffers/protobuf/blob/master/java/core/src/main/java/com/google/protobuf/RopeByteString.java\">RopeByteString</a> implementation).</p>\n<p>I\u2019m not sure if anything solves the problem of having a very long prefix and attempting to increment the last key (entirely). If much of the prefix is something like a subspace prefix and can be memoized, I suppose you could imagine keeping around something like was an array of <code>[pointer to subspace prefix, pointer to \"ABC\"]</code> and another that was <code>[pointer to subspace prefix, pointer to \"ABD\"]</code>. Then the buffers for <code>\"ABC\"</code> and <code>\"ABD\"</code> need to be allocated, but the subspace prefix buffer pointer can be shared. So it\u2019s not a zero-allocation operation, but hopefully fewer?</p>",
        "post_number": 2,
        "post_type": 1,
        "posts_count": 4,
        "updated_at": "2018-11-12T17:58:19.492Z",
        "reply_count": 1,
        "reply_to_post_number": null,
        "quote_count": 0,
        "incoming_link_count": 0,
        "reads": 26,
        "readers_count": 25,
        "score": 25.2,
        "yours": false,
        "topic_id": 859,
        "topic_slug": "adding-new-apis-to-specify-keys-as-a-list-of-chunks-allowing-zero-copy-serialization",
        "display_username": "Alec Grieser",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "link_counts": [
          {
            "url": "https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/ByteString",
            "internal": false,
            "reflection": false,
            "title": "ByteString",
            "clicks": 0
          },
          {
            "url": "https://github.com/protocolbuffers/protobuf/blob/master/java/core/src/main/java/com/google/protobuf/RopeByteString.java",
            "internal": false,
            "reflection": false,
            "title": "protobuf/RopeByteString.java at master \u00b7 protocolbuffers/protobuf \u00b7 GitHub",
            "clicks": 0
          }
        ],
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [
          {
            "id": 2,
            "count": 1
          }
        ],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 8,
        "hidden": false,
        "trust_level": 4,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/adding-new-apis-to-specify-keys-as-a-list-of-chunks-allowing-zero-copy-serialization/859/2",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 2633,
        "name": "Christophe Chevalier",
        "username": "KrzysFR",
        "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
        "created_at": "2018-11-12T19:13:33.599Z",
        "cooked": "<p>Well you are right that \u201czero\u201d-copy is not possible, because someone will have to merge all the chunks into a consecutive buffer, so I guess we can only settle for \u201cat least one copy\u201d.</p>\n<p>Currently, the one that has to do it is the binding. But it will have to allocate a buffer, copy the fragments into it, and then call the FDB C client that will also allocate another buffer, and copy the bytes into <em>that</em> buffer. The intermediate buffer between the binding and the C client is a bit redundant and makes the whole thing \u201cat least two copies\u201d.</p>\n<p>It\u2019s true that the network thread would have a bit more things to do, though I\u2019m not sure if the overhead is that great compared to getting rid of one allocation/copy: Currently, it will copy the whole key using a single <code>memmove</code> call, while with a list of chunks, it would need to do several <code>memmove</code>s on smaller chunks (with the same total number of bytes). I <em>think</em> that in the normal case, there could be between 2 or 3 chunks per key.</p>\n<p>Regarding the range with long prefix, the idea would be that the \u2018end\u2019 key would become <code>[pointer to subspace prefix, pointer to \"AB\" (minus the C), pointer to a single \"D\" in a memory sprite]</code> so here I would reuse the same buffer as <code>\"ABC\"</code> without mutating it. The subspace prefix is already cached (and I already also cache the end key for the whole subspace in the .NET binding), the issue is with indexes that have long suffixes (128 bit guids, etc\u2026) where the value is not known in advance.</p>",
        "post_number": 3,
        "post_type": 1,
        "posts_count": 4,
        "updated_at": "2018-11-12T19:16:59.989Z",
        "reply_count": 0,
        "reply_to_post_number": 2,
        "quote_count": 0,
        "incoming_link_count": 0,
        "reads": 25,
        "readers_count": 24,
        "score": 5.0,
        "yours": false,
        "topic_id": 859,
        "topic_slug": "adding-new-apis-to-specify-keys-as-a-list-of-chunks-allowing-zero-copy-serialization",
        "display_username": "Christophe Chevalier",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "reply_to_user": {
          "id": 8,
          "username": "alloc",
          "name": "Alec Grieser",
          "avatar_template": "/user_avatar/forums.foundationdb.org/alloc/{size}/9_2.png"
        },
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 53,
        "hidden": false,
        "trust_level": 2,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/adding-new-apis-to-specify-keys-as-a-list-of-chunks-allowing-zero-copy-serialization/859/3",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      },
      {
        "id": 2634,
        "name": "Christophe Chevalier",
        "username": "KrzysFR",
        "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
        "created_at": "2018-11-12T19:21:50.438Z",
        "cooked": "<p>Oh and in case this was not clear, I\u2019m not asking that the FDB C client keep the list of chunks for the whole lifetime of the transaction: the goal is only to get rid of at least one buffer copy. The contract would be the same as before: the C client <em>copies</em> the bytes of the key somewhere, and once the method call to <code>fdb_transaction_xxx(...)</code> returns, the caller is free to reuse the buffers (as it is currently).</p>",
        "post_number": 4,
        "post_type": 1,
        "posts_count": 4,
        "updated_at": "2018-11-12T19:21:50.438Z",
        "reply_count": 0,
        "reply_to_post_number": null,
        "quote_count": 0,
        "incoming_link_count": 0,
        "reads": 24,
        "readers_count": 23,
        "score": 4.8,
        "yours": false,
        "topic_id": 859,
        "topic_slug": "adding-new-apis-to-specify-keys-as-a-list-of-chunks-allowing-zero-copy-serialization",
        "display_username": "Christophe Chevalier",
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_bg_color": null,
        "flair_color": null,
        "flair_group_id": null,
        "badges_granted": [],
        "version": 1,
        "can_edit": false,
        "can_delete": false,
        "can_recover": false,
        "can_see_hidden_post": false,
        "can_wiki": false,
        "read": true,
        "user_title": null,
        "bookmarked": false,
        "actions_summary": [],
        "moderator": false,
        "admin": false,
        "staff": false,
        "user_id": 53,
        "hidden": false,
        "trust_level": 2,
        "deleted_at": null,
        "user_deleted": false,
        "edit_reason": null,
        "can_view_edit_history": true,
        "wiki": false,
        "post_url": "/t/adding-new-apis-to-specify-keys-as-a-list-of-chunks-allowing-zero-copy-serialization/859/4",
        "can_accept_answer": false,
        "can_unaccept_answer": false,
        "accepted_answer": false,
        "topic_accepted_answer": null
      }
    ],
    "stream": [
      2616,
      2628,
      2633,
      2634
    ]
  },
  "timeline_lookup": [
    [
      1,
      2537
    ],
    [
      2,
      2535
    ]
  ],
  "suggested_topics": [],
  "tags": [],
  "tags_descriptions": {},
  "fancy_title": "Adding new APIs to specify keys as a list of chunks, allowing &ldquo;zero-copy&rdquo; serialization",
  "id": 859,
  "title": "Adding new APIs to specify keys as a list of chunks, allowing \"zero-copy\" serialization",
  "posts_count": 4,
  "created_at": "2018-11-10T14:52:35.322Z",
  "views": 812,
  "reply_count": 1,
  "like_count": 1,
  "last_posted_at": "2018-11-12T19:21:50.438Z",
  "visible": true,
  "closed": false,
  "archived": false,
  "has_summary": false,
  "archetype": "regular",
  "slug": "adding-new-apis-to-specify-keys-as-a-list-of-chunks-allowing-zero-copy-serialization",
  "category_id": 8,
  "word_count": 1388,
  "deleted_at": null,
  "user_id": 53,
  "featured_link": null,
  "pinned_globally": false,
  "pinned_at": null,
  "pinned_until": null,
  "image_url": null,
  "slow_mode_seconds": 0,
  "draft": null,
  "draft_key": "topic_859",
  "draft_sequence": null,
  "unpinned": null,
  "pinned": false,
  "current_post_number": 1,
  "highest_post_number": 4,
  "deleted_by": null,
  "actions_summary": [
    {
      "id": 4,
      "count": 0,
      "hidden": false,
      "can_act": false
    },
    {
      "id": 8,
      "count": 0,
      "hidden": false,
      "can_act": false
    },
    {
      "id": 10,
      "count": 0,
      "hidden": false,
      "can_act": false
    },
    {
      "id": 7,
      "count": 0,
      "hidden": false,
      "can_act": false
    }
  ],
  "chunk_size": 20,
  "bookmarked": false,
  "topic_timer": null,
  "message_bus_last_id": 0,
  "participant_count": 2,
  "show_read_indicator": false,
  "thumbnails": null,
  "slow_mode_enabled_until": null,
  "tags_disable_ads": false,
  "related_topics": [
    {
      "fancy_title": "Storing one billion floats with dense keys",
      "id": 1328,
      "title": "Storing one billion floats with dense keys",
      "slug": "storing-one-billion-floats-with-dense-keys",
      "posts_count": 2,
      "reply_count": 0,
      "highest_post_number": 2,
      "image_url": null,
      "created_at": "2019-04-23T18:31:29.919Z",
      "last_posted_at": "2019-04-23T18:58:38.558Z",
      "bumped": true,
      "bumped_at": "2019-04-23T18:58:38.558Z",
      "archetype": "regular",
      "unseen": false,
      "pinned": false,
      "unpinned": null,
      "visible": true,
      "closed": false,
      "archived": false,
      "bookmarked": null,
      "liked": null,
      "tags": [],
      "tags_descriptions": {},
      "like_count": 1,
      "views": 470,
      "category_id": 7,
      "featured_link": null,
      "has_accepted_answer": false,
      "posters": [
        {
          "extras": null,
          "description": "Original Poster",
          "user": {
            "id": 570,
            "username": "johollow",
            "name": "",
            "avatar_template": "https://avatars.discourse-cdn.com/v4/letter/j/7ab992/{size}.png",
            "trust_level": 1
          }
        },
        {
          "extras": "latest",
          "description": "Most Recent Poster",
          "user": {
            "id": 81,
            "username": "ryanworl",
            "name": "Ryan Worl",
            "avatar_template": "/user_avatar/forums.foundationdb.org/ryanworl/{size}/440_2.png",
            "trust_level": 3
          }
        }
      ]
    },
    {
      "fancy_title": "Application design using Subspace and Tuple",
      "id": 452,
      "title": "Application design using Subspace and Tuple",
      "slug": "application-design-using-subspace-and-tuple",
      "posts_count": 9,
      "reply_count": 7,
      "highest_post_number": 9,
      "image_url": null,
      "created_at": "2018-05-22T21:46:43.537Z",
      "last_posted_at": "2018-07-14T21:02:50.010Z",
      "bumped": true,
      "bumped_at": "2018-07-14T21:02:50.010Z",
      "archetype": "regular",
      "unseen": false,
      "pinned": false,
      "unpinned": null,
      "visible": true,
      "closed": false,
      "archived": false,
      "bookmarked": null,
      "liked": null,
      "tags": [],
      "tags_descriptions": {},
      "like_count": 5,
      "views": 3678,
      "category_id": 7,
      "featured_link": null,
      "has_accepted_answer": false,
      "posters": [
        {
          "extras": null,
          "description": "Original Poster",
          "user": {
            "id": 211,
            "username": "brk0v",
            "name": "Viacheslav Biriukov",
            "avatar_template": "/user_avatar/forums.foundationdb.org/brk0v/{size}/173_2.png",
            "trust_level": 1
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 53,
            "username": "KrzysFR",
            "name": "Christophe Chevalier",
            "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
            "trust_level": 2
          }
        },
        {
          "extras": "latest",
          "description": "Most Recent Poster",
          "user": {
            "id": 317,
            "username": "Lundin",
            "name": "Pontus Lundin",
            "avatar_template": "https://avatars.discourse-cdn.com/v4/letter/l/dfb087/{size}.png",
            "trust_level": 1
          }
        }
      ]
    },
    {
      "fancy_title": "Missing API for getting just the count of a key range?",
      "id": 444,
      "title": "Missing API for getting just the count of a key range?",
      "slug": "missing-api-for-getting-just-the-count-of-a-key-range",
      "posts_count": 14,
      "reply_count": 9,
      "highest_post_number": 14,
      "image_url": null,
      "created_at": "2018-05-21T09:23:36.938Z",
      "last_posted_at": "2018-09-10T16:25:03.060Z",
      "bumped": true,
      "bumped_at": "2018-09-10T16:25:03.060Z",
      "archetype": "regular",
      "unseen": false,
      "pinned": false,
      "unpinned": null,
      "visible": true,
      "closed": false,
      "archived": false,
      "bookmarked": null,
      "liked": null,
      "tags": [],
      "tags_descriptions": {},
      "like_count": 4,
      "views": 3599,
      "category_id": 8,
      "featured_link": null,
      "has_accepted_answer": false,
      "posters": [
        {
          "extras": null,
          "description": "Original Poster",
          "user": {
            "id": 208,
            "username": "cloudspeech",
            "name": "Cloudspeech",
            "avatar_template": "/user_avatar/forums.foundationdb.org/cloudspeech/{size}/330_2.png",
            "trust_level": 1
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 31,
            "username": "dicklacara",
            "name": "Richard Applebaum",
            "avatar_template": "https://avatars.discourse-cdn.com/v4/letter/d/8797f3/{size}.png",
            "trust_level": 1
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 173,
            "username": "jkominek",
            "name": "Jay Kominek",
            "avatar_template": "/user_avatar/forums.foundationdb.org/jkominek/{size}/140_2.png",
            "trust_level": 2
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 53,
            "username": "KrzysFR",
            "name": "Christophe Chevalier",
            "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
            "trust_level": 2
          }
        },
        {
          "extras": "latest",
          "description": "Most Recent Poster",
          "user": {
            "id": 8,
            "username": "alloc",
            "name": "Alec Grieser",
            "avatar_template": "/user_avatar/forums.foundationdb.org/alloc/{size}/9_2.png",
            "trust_level": 4
          }
        }
      ]
    },
    {
      "fancy_title": "Log abstraction on FoundationDB",
      "id": 117,
      "title": "Log abstraction on FoundationDB",
      "slug": "log-abstraction-on-foundationdb",
      "posts_count": 10,
      "reply_count": 3,
      "highest_post_number": 10,
      "image_url": null,
      "created_at": "2018-04-20T10:47:11.941Z",
      "last_posted_at": "2018-05-03T17:35:34.126Z",
      "bumped": true,
      "bumped_at": "2018-05-03T17:35:34.126Z",
      "archetype": "regular",
      "unseen": false,
      "pinned": false,
      "unpinned": null,
      "visible": true,
      "closed": false,
      "archived": false,
      "bookmarked": null,
      "liked": null,
      "tags": [],
      "tags_descriptions": {},
      "like_count": 3,
      "views": 3110,
      "category_id": 5,
      "featured_link": null,
      "has_accepted_answer": false,
      "posters": [
        {
          "extras": "latest",
          "description": "Original Poster, Most Recent Poster",
          "user": {
            "id": 81,
            "username": "ryanworl",
            "name": "Ryan Worl",
            "avatar_template": "/user_avatar/forums.foundationdb.org/ryanworl/{size}/440_2.png",
            "trust_level": 3
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 22,
            "username": "dave",
            "name": "David Scherer",
            "avatar_template": "/user_avatar/forums.foundationdb.org/dave/{size}/89_2.png",
            "trust_level": 1
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 78,
            "username": "pineapple",
            "name": "Brian Haslet",
            "avatar_template": "https://avatars.discourse-cdn.com/v4/letter/p/7993a0/{size}.png",
            "trust_level": 1
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 8,
            "username": "alloc",
            "name": "Alec Grieser",
            "avatar_template": "/user_avatar/forums.foundationdb.org/alloc/{size}/9_2.png",
            "trust_level": 4
          }
        },
        {
          "extras": null,
          "description": "Frequent Poster",
          "user": {
            "id": 53,
            "username": "KrzysFR",
            "name": "Christophe Chevalier",
            "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
            "trust_level": 2
          }
        }
      ]
    },
    {
      "fancy_title": "Is it possible (or useful) to fetch the last key?",
      "id": 400,
      "title": "Is it possible (or useful) to fetch the last key?",
      "slug": "is-it-possible-or-useful-to-fetch-the-last-key",
      "posts_count": 3,
      "reply_count": 1,
      "highest_post_number": 3,
      "image_url": null,
      "created_at": "2018-05-11T17:25:32.373Z",
      "last_posted_at": "2018-05-11T17:41:25.079Z",
      "bumped": true,
      "bumped_at": "2018-05-11T17:41:25.079Z",
      "archetype": "regular",
      "unseen": false,
      "pinned": false,
      "unpinned": null,
      "visible": true,
      "closed": false,
      "archived": false,
      "bookmarked": null,
      "liked": null,
      "tags": [
        "bindings"
      ],
      "tags_descriptions": {},
      "like_count": 3,
      "views": 1240,
      "category_id": 7,
      "featured_link": null,
      "has_accepted_answer": false,
      "posters": [
        {
          "extras": null,
          "description": "Original Poster",
          "user": {
            "id": 41,
            "username": "amirouche",
            "name": "Amirouche",
            "avatar_template": "/user_avatar/forums.foundationdb.org/amirouche/{size}/1911_2.png",
            "trust_level": 2
          }
        },
        {
          "extras": "latest",
          "description": "Most Recent Poster",
          "user": {
            "id": 12,
            "username": "ajbeamon",
            "name": "A.J. Beamon",
            "avatar_template": "/user_avatar/forums.foundationdb.org/ajbeamon/{size}/13_2.png",
            "admin": true,
            "trust_level": 4
          }
        }
      ]
    }
  ],
  "summarizable": false,
  "can_vote": false,
  "vote_count": 0,
  "user_voted": false,
  "discourse_zendesk_plugin_zendesk_id": null,
  "discourse_zendesk_plugin_zendesk_url": "https://your-url.zendesk.com/agent/tickets/",
  "details": {
    "can_edit": false,
    "notification_level": 1,
    "participants": [
      {
        "id": 53,
        "username": "KrzysFR",
        "name": "Christophe Chevalier",
        "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png",
        "post_count": 3,
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_color": null,
        "flair_bg_color": null,
        "flair_group_id": null,
        "trust_level": 2
      },
      {
        "id": 8,
        "username": "alloc",
        "name": "Alec Grieser",
        "avatar_template": "/user_avatar/forums.foundationdb.org/alloc/{size}/9_2.png",
        "post_count": 1,
        "primary_group_name": null,
        "flair_name": null,
        "flair_url": null,
        "flair_color": null,
        "flair_bg_color": null,
        "flair_group_id": null,
        "trust_level": 4
      }
    ],
    "created_by": {
      "id": 53,
      "username": "KrzysFR",
      "name": "Christophe Chevalier",
      "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png"
    },
    "last_poster": {
      "id": 53,
      "username": "KrzysFR",
      "name": "Christophe Chevalier",
      "avatar_template": "/user_avatar/forums.foundationdb.org/krzysfr/{size}/43_2.png"
    }
  },
  "bookmarks": []
}